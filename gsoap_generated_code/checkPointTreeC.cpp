/* checkPointTreeC.cpp
   Generated by gSOAP 2.3.8 from RealityGridTree.h
   Copyright (C) 2001-2003 Genivia inc.
   All Rights Reserved.
*/
#include "checkPointTreeH.h"

SOAP_BEGIN_NAMESPACE(checkPointTree)

SOAP_SOURCE_STAMP("@(#) checkPointTreeC.cpp ver 2.3.8 2003-11-24 15:20:32 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL);
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = (struct SOAP_ENV__Fault*)soap_malloc(soap, sizeof(struct SOAP_ENV__Fault));
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	return soap_out_SOAP_ENV__Fault(soap, "SOAP-ENV:Fault", 0, soap->fault, NULL);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_in_SOAP_ENV__Fault(soap, "SOAP-ENV:Fault", NULL, NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Detail;
	return (const char**)&soap->fault->detail;
}

#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	for (;;)
		if (!soap_getelement(soap, &t))
			if (soap->error || soap_ignore_element(soap))
				break;
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}

SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_tree__destroyResponse:
		return soap_in_tree__destroyResponse(soap, NULL, NULL, "tree:destroyResponse");
	case SOAP_TYPE_tree__getInputFileResponse:
		return soap_in_tree__getInputFileResponse(soap, NULL, NULL, "tree:getInputFileResponse");
	case SOAP_TYPE_tree__getSteeringCommandsResponse:
		return soap_in_tree__getSteeringCommandsResponse(soap, NULL, NULL, "tree:getSteeringCommandsResponse");
	case SOAP_TYPE_tree__requestTerminationBeforeResponse:
		return soap_in_tree__requestTerminationBeforeResponse(soap, NULL, NULL, "tree:requestTerminationBeforeResponse");
	case SOAP_TYPE_tree__getChildNodesResponse:
		return soap_in_tree__getChildNodesResponse(soap, NULL, NULL, "tree:getChildNodesResponse");
	case SOAP_TYPE_tree__setCheckPointDataResponse:
		return soap_in_tree__setCheckPointDataResponse(soap, NULL, NULL, "tree:setCheckPointDataResponse");
	case SOAP_TYPE_tree__findServiceDataResponse:
		return soap_in_tree__findServiceDataResponse(soap, NULL, NULL, "tree:findServiceDataResponse");
	case SOAP_TYPE_tree__getCheckPointDataResponse:
		return soap_in_tree__getCheckPointDataResponse(soap, NULL, NULL, "tree:getCheckPointDataResponse");
	case SOAP_TYPE_tree__addNodeResponse:
		return soap_in_tree__addNodeResponse(soap, NULL, NULL, "tree:addNodeResponse");
	case SOAP_TYPE_tree__requestTerminationAfterResponse:
		return soap_in_tree__requestTerminationAfterResponse(soap, NULL, NULL, "tree:requestTerminationAfterResponse");
	case SOAP_TYPE_tree__getParentNodeResponse:
		return soap_in_tree__getParentNodeResponse(soap, NULL, NULL, "tree:getParentNodeResponse");
	case SOAP_TYPE_fact__destroyResponse:
		return soap_in_fact__destroyResponse(soap, NULL, NULL, "fact:destroyResponse");
	case SOAP_TYPE_fact__requestTerminationAfterResponse:
		return soap_in_fact__requestTerminationAfterResponse(soap, NULL, NULL, "fact:requestTerminationAfterResponse");
	case SOAP_TYPE_fact__createNewTreeResponse:
		return soap_in_fact__createNewTreeResponse(soap, NULL, NULL, "fact:createNewTreeResponse");
	case SOAP_TYPE_fact__getActiveTreesResponse:
		return soap_in_fact__getActiveTreesResponse(soap, NULL, NULL, "fact:getActiveTreesResponse");
	case SOAP_TYPE_fact__findByHandleResponse:
		return soap_in_fact__findByHandleResponse(soap, NULL, NULL, "fact:findByHandleResponse");
	case SOAP_TYPE_fact__findServiceDataResponse:
		return soap_in_fact__findServiceDataResponse(soap, NULL, NULL, "fact:findServiceDataResponse");
	case SOAP_TYPE_fact__requestTerminationBeforeResponse:
		return soap_in_fact__requestTerminationBeforeResponse(soap, NULL, NULL, "fact:requestTerminationBeforeResponse");
	case SOAP_TYPE_tree__addNode:
		return soap_in_tree__addNode(soap, NULL, NULL, "tree:addNode");
	case SOAP_TYPE_tree__getParentNode:
		return soap_in_tree__getParentNode(soap, NULL, NULL, "tree:getParentNode");
	case SOAP_TYPE_tree__getCheckPointData:
		return soap_in_tree__getCheckPointData(soap, NULL, NULL, "tree:getCheckPointData");
	case SOAP_TYPE_tree__requestTerminationBefore:
		return soap_in_tree__requestTerminationBefore(soap, NULL, NULL, "tree:requestTerminationBefore");
	case SOAP_TYPE_tree__getSteeringCommands:
		return soap_in_tree__getSteeringCommands(soap, NULL, NULL, "tree:getSteeringCommands");
	case SOAP_TYPE_tree__destroy:
		return soap_in_tree__destroy(soap, NULL, NULL, "tree:destroy");
	case SOAP_TYPE_tree__setCheckPointData:
		return soap_in_tree__setCheckPointData(soap, NULL, NULL, "tree:setCheckPointData");
	case SOAP_TYPE_tree__findServiceData:
		return soap_in_tree__findServiceData(soap, NULL, NULL, "tree:findServiceData");
	case SOAP_TYPE_tree__getInputFile:
		return soap_in_tree__getInputFile(soap, NULL, NULL, "tree:getInputFile");
	case SOAP_TYPE_tree__getChildNodes:
		return soap_in_tree__getChildNodes(soap, NULL, NULL, "tree:getChildNodes");
	case SOAP_TYPE_tree__requestTerminationAfter:
		return soap_in_tree__requestTerminationAfter(soap, NULL, NULL, "tree:requestTerminationAfter");
	case SOAP_TYPE_fact__requestTerminationAfter:
		return soap_in_fact__requestTerminationAfter(soap, NULL, NULL, "fact:requestTerminationAfter");
	case SOAP_TYPE_fact__requestTerminationBefore:
		return soap_in_fact__requestTerminationBefore(soap, NULL, NULL, "fact:requestTerminationBefore");
	case SOAP_TYPE_fact__getActiveTrees:
		return soap_in_fact__getActiveTrees(soap, NULL, NULL, "fact:getActiveTrees");
	case SOAP_TYPE_fact__findServiceData:
		return soap_in_fact__findServiceData(soap, NULL, NULL, "fact:findServiceData");
	case SOAP_TYPE_fact__destroy:
		return soap_in_fact__destroy(soap, NULL, NULL, "fact:destroy");
	case SOAP_TYPE_fact__findByHandle:
		return soap_in_fact__findByHandle(soap, NULL, NULL, "fact:findByHandle");
	case SOAP_TYPE_fact__createNewTree:
		return soap_in_fact__createNewTree(soap, NULL, NULL, "fact:createNewTree");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_PointerTotree__addNodeResponse:
		return soap_in_PointerTotree__addNodeResponse(soap, NULL, NULL, "tree:addNodeResponse");
	case SOAP_TYPE_PointerTotree__getParentNodeResponse:
		return soap_in_PointerTotree__getParentNodeResponse(soap, NULL, NULL, "tree:getParentNodeResponse");
	case SOAP_TYPE_PointerTotree__getCheckPointDataResponse:
		return soap_in_PointerTotree__getCheckPointDataResponse(soap, NULL, NULL, "tree:getCheckPointDataResponse");
	case SOAP_TYPE_PointerTotree__requestTerminationBeforeResponse:
		return soap_in_PointerTotree__requestTerminationBeforeResponse(soap, NULL, NULL, "tree:requestTerminationBeforeResponse");
	case SOAP_TYPE_PointerTotree__getSteeringCommandsResponse:
		return soap_in_PointerTotree__getSteeringCommandsResponse(soap, NULL, NULL, "tree:getSteeringCommandsResponse");
	case SOAP_TYPE_PointerTotree__destroyResponse:
		return soap_in_PointerTotree__destroyResponse(soap, NULL, NULL, "tree:destroyResponse");
	case SOAP_TYPE_PointerTotree__setCheckPointDataResponse:
		return soap_in_PointerTotree__setCheckPointDataResponse(soap, NULL, NULL, "tree:setCheckPointDataResponse");
	case SOAP_TYPE_PointerTotree__findServiceDataResponse:
		return soap_in_PointerTotree__findServiceDataResponse(soap, NULL, NULL, "tree:findServiceDataResponse");
	case SOAP_TYPE_PointerTotree__getInputFileResponse:
		return soap_in_PointerTotree__getInputFileResponse(soap, NULL, NULL, "tree:getInputFileResponse");
	case SOAP_TYPE_PointerTotree__getChildNodesResponse:
		return soap_in_PointerTotree__getChildNodesResponse(soap, NULL, NULL, "tree:getChildNodesResponse");
	case SOAP_TYPE_PointerTotree__requestTerminationAfterResponse:
		return soap_in_PointerTotree__requestTerminationAfterResponse(soap, NULL, NULL, "tree:requestTerminationAfterResponse");
	case SOAP_TYPE_PointerTofact__requestTerminationAfterResponse:
		return soap_in_PointerTofact__requestTerminationAfterResponse(soap, NULL, NULL, "fact:requestTerminationAfterResponse");
	case SOAP_TYPE_PointerTofact__requestTerminationBeforeResponse:
		return soap_in_PointerTofact__requestTerminationBeforeResponse(soap, NULL, NULL, "fact:requestTerminationBeforeResponse");
	case SOAP_TYPE_PointerTofact__getActiveTreesResponse:
		return soap_in_PointerTofact__getActiveTreesResponse(soap, NULL, NULL, "fact:getActiveTreesResponse");
	case SOAP_TYPE_PointerTofact__findServiceDataResponse:
		return soap_in_PointerTofact__findServiceDataResponse(soap, NULL, NULL, "fact:findServiceDataResponse");
	case SOAP_TYPE_PointerTofact__destroyResponse:
		return soap_in_PointerTofact__destroyResponse(soap, NULL, NULL, "fact:destroyResponse");
	case SOAP_TYPE_PointerTofact__findByHandleResponse:
		return soap_in_PointerTofact__findByHandleResponse(soap, NULL, NULL, "fact:findByHandleResponse");
	case SOAP_TYPE_PointerTofact__createNewTreeResponse:
		return soap_in_PointerTofact__createNewTreeResponse(soap, NULL, NULL, "fact:createNewTreeResponse");
	case SOAP_TYPE_xsd__string:
	{	char **s;
		s = soap_in_xsd__string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
		if (!*soap->type)
			return NULL;
		if (!soap_match_tag(soap, soap->type, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, soap->type, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, soap->type, "tree:destroyResponse"))
		{	*type = SOAP_TYPE_tree__destroyResponse;
			return soap_in_tree__destroyResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, soap->type, "tree:getInputFileResponse"))
		{	*type = SOAP_TYPE_tree__getInputFileResponse;
			return soap_in_tree__getInputFileResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, soap->type, "tree:getSteeringCommandsResponse"))
		{	*type = SOAP_TYPE_tree__getSteeringCommandsResponse;
			return soap_in_tree__getSteeringCommandsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, soap->type, "tree:requestTerminationBeforeResponse"))
		{	*type = SOAP_TYPE_tree__requestTerminationBeforeResponse;
			return soap_in_tree__requestTerminationBeforeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, soap->type, "tree:getChildNodesResponse"))
		{	*type = SOAP_TYPE_tree__getChildNodesResponse;
			return soap_in_tree__getChildNodesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, soap->type, "tree:setCheckPointDataResponse"))
		{	*type = SOAP_TYPE_tree__setCheckPointDataResponse;
			return soap_in_tree__setCheckPointDataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, soap->type, "tree:findServiceDataResponse"))
		{	*type = SOAP_TYPE_tree__findServiceDataResponse;
			return soap_in_tree__findServiceDataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, soap->type, "tree:getCheckPointDataResponse"))
		{	*type = SOAP_TYPE_tree__getCheckPointDataResponse;
			return soap_in_tree__getCheckPointDataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, soap->type, "tree:addNodeResponse"))
		{	*type = SOAP_TYPE_tree__addNodeResponse;
			return soap_in_tree__addNodeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, soap->type, "tree:requestTerminationAfterResponse"))
		{	*type = SOAP_TYPE_tree__requestTerminationAfterResponse;
			return soap_in_tree__requestTerminationAfterResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, soap->type, "tree:getParentNodeResponse"))
		{	*type = SOAP_TYPE_tree__getParentNodeResponse;
			return soap_in_tree__getParentNodeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, soap->type, "fact:destroyResponse"))
		{	*type = SOAP_TYPE_fact__destroyResponse;
			return soap_in_fact__destroyResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, soap->type, "fact:requestTerminationAfterResponse"))
		{	*type = SOAP_TYPE_fact__requestTerminationAfterResponse;
			return soap_in_fact__requestTerminationAfterResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, soap->type, "fact:createNewTreeResponse"))
		{	*type = SOAP_TYPE_fact__createNewTreeResponse;
			return soap_in_fact__createNewTreeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, soap->type, "fact:getActiveTreesResponse"))
		{	*type = SOAP_TYPE_fact__getActiveTreesResponse;
			return soap_in_fact__getActiveTreesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, soap->type, "fact:findByHandleResponse"))
		{	*type = SOAP_TYPE_fact__findByHandleResponse;
			return soap_in_fact__findByHandleResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, soap->type, "fact:findServiceDataResponse"))
		{	*type = SOAP_TYPE_fact__findServiceDataResponse;
			return soap_in_fact__findServiceDataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, soap->type, "fact:requestTerminationBeforeResponse"))
		{	*type = SOAP_TYPE_fact__requestTerminationBeforeResponse;
			return soap_in_fact__requestTerminationBeforeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, soap->type, "tree:addNode"))
		{	*type = SOAP_TYPE_tree__addNode;
			return soap_in_tree__addNode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, soap->type, "tree:getParentNode"))
		{	*type = SOAP_TYPE_tree__getParentNode;
			return soap_in_tree__getParentNode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, soap->type, "tree:getCheckPointData"))
		{	*type = SOAP_TYPE_tree__getCheckPointData;
			return soap_in_tree__getCheckPointData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, soap->type, "tree:requestTerminationBefore"))
		{	*type = SOAP_TYPE_tree__requestTerminationBefore;
			return soap_in_tree__requestTerminationBefore(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, soap->type, "tree:getSteeringCommands"))
		{	*type = SOAP_TYPE_tree__getSteeringCommands;
			return soap_in_tree__getSteeringCommands(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, soap->type, "tree:destroy"))
		{	*type = SOAP_TYPE_tree__destroy;
			return soap_in_tree__destroy(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, soap->type, "tree:setCheckPointData"))
		{	*type = SOAP_TYPE_tree__setCheckPointData;
			return soap_in_tree__setCheckPointData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, soap->type, "tree:findServiceData"))
		{	*type = SOAP_TYPE_tree__findServiceData;
			return soap_in_tree__findServiceData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, soap->type, "tree:getInputFile"))
		{	*type = SOAP_TYPE_tree__getInputFile;
			return soap_in_tree__getInputFile(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, soap->type, "tree:getChildNodes"))
		{	*type = SOAP_TYPE_tree__getChildNodes;
			return soap_in_tree__getChildNodes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, soap->type, "tree:requestTerminationAfter"))
		{	*type = SOAP_TYPE_tree__requestTerminationAfter;
			return soap_in_tree__requestTerminationAfter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, soap->type, "fact:requestTerminationAfter"))
		{	*type = SOAP_TYPE_fact__requestTerminationAfter;
			return soap_in_fact__requestTerminationAfter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, soap->type, "fact:requestTerminationBefore"))
		{	*type = SOAP_TYPE_fact__requestTerminationBefore;
			return soap_in_fact__requestTerminationBefore(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, soap->type, "fact:getActiveTrees"))
		{	*type = SOAP_TYPE_fact__getActiveTrees;
			return soap_in_fact__getActiveTrees(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, soap->type, "fact:findServiceData"))
		{	*type = SOAP_TYPE_fact__findServiceData;
			return soap_in_fact__findServiceData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, soap->type, "fact:destroy"))
		{	*type = SOAP_TYPE_fact__destroy;
			return soap_in_fact__destroy(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, soap->type, "fact:findByHandle"))
		{	*type = SOAP_TYPE_fact__findByHandle;
			return soap_in_fact__findByHandle(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, soap->type, "fact:createNewTree"))
		{	*type = SOAP_TYPE_fact__createNewTree;
			return soap_in_fact__createNewTree(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, soap->type, "QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, soap->type, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_xsd__string;
			s = soap_in_xsd__string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, soap->type, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
	return NULL;
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{	if (soap->mode & SOAP_XML_STRICT)
		return SOAP_TAG_MISMATCH;
	if (!soap_peek_element(soap))
	{	int t;
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unknown element '%s' (level=%u, %d)\n", soap->tag, soap->level, soap->body));
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if ((soap->mode & SOAP_IO_LENGTH) ? pp->mark1 == 2 : pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_tree__destroyResponse:
		return ((tree__destroyResponse *)ptr)->soap_out(soap, tag, id, "tree:destroyResponse");
	case SOAP_TYPE_tree__getInputFileResponse:
		return ((tree__getInputFileResponse *)ptr)->soap_out(soap, tag, id, "tree:getInputFileResponse");
	case SOAP_TYPE_tree__getSteeringCommandsResponse:
		return ((tree__getSteeringCommandsResponse *)ptr)->soap_out(soap, tag, id, "tree:getSteeringCommandsResponse");
	case SOAP_TYPE_tree__requestTerminationBeforeResponse:
		return ((tree__requestTerminationBeforeResponse *)ptr)->soap_out(soap, tag, id, "tree:requestTerminationBeforeResponse");
	case SOAP_TYPE_tree__getChildNodesResponse:
		return ((tree__getChildNodesResponse *)ptr)->soap_out(soap, tag, id, "tree:getChildNodesResponse");
	case SOAP_TYPE_tree__setCheckPointDataResponse:
		return ((tree__setCheckPointDataResponse *)ptr)->soap_out(soap, tag, id, "tree:setCheckPointDataResponse");
	case SOAP_TYPE_tree__findServiceDataResponse:
		return ((tree__findServiceDataResponse *)ptr)->soap_out(soap, tag, id, "tree:findServiceDataResponse");
	case SOAP_TYPE_tree__getCheckPointDataResponse:
		return ((tree__getCheckPointDataResponse *)ptr)->soap_out(soap, tag, id, "tree:getCheckPointDataResponse");
	case SOAP_TYPE_tree__addNodeResponse:
		return ((tree__addNodeResponse *)ptr)->soap_out(soap, tag, id, "tree:addNodeResponse");
	case SOAP_TYPE_tree__requestTerminationAfterResponse:
		return ((tree__requestTerminationAfterResponse *)ptr)->soap_out(soap, tag, id, "tree:requestTerminationAfterResponse");
	case SOAP_TYPE_tree__getParentNodeResponse:
		return ((tree__getParentNodeResponse *)ptr)->soap_out(soap, tag, id, "tree:getParentNodeResponse");
	case SOAP_TYPE_fact__destroyResponse:
		return ((fact__destroyResponse *)ptr)->soap_out(soap, tag, id, "fact:destroyResponse");
	case SOAP_TYPE_fact__requestTerminationAfterResponse:
		return ((fact__requestTerminationAfterResponse *)ptr)->soap_out(soap, tag, id, "fact:requestTerminationAfterResponse");
	case SOAP_TYPE_fact__createNewTreeResponse:
		return ((fact__createNewTreeResponse *)ptr)->soap_out(soap, tag, id, "fact:createNewTreeResponse");
	case SOAP_TYPE_fact__getActiveTreesResponse:
		return ((fact__getActiveTreesResponse *)ptr)->soap_out(soap, tag, id, "fact:getActiveTreesResponse");
	case SOAP_TYPE_fact__findByHandleResponse:
		return ((fact__findByHandleResponse *)ptr)->soap_out(soap, tag, id, "fact:findByHandleResponse");
	case SOAP_TYPE_fact__findServiceDataResponse:
		return ((fact__findServiceDataResponse *)ptr)->soap_out(soap, tag, id, "fact:findServiceDataResponse");
	case SOAP_TYPE_fact__requestTerminationBeforeResponse:
		return ((fact__requestTerminationBeforeResponse *)ptr)->soap_out(soap, tag, id, "fact:requestTerminationBeforeResponse");
	case SOAP_TYPE_tree__addNode:
		return soap_out_tree__addNode(soap, tag, id, (const struct tree__addNode *)ptr, "tree:addNode");
	case SOAP_TYPE_tree__getParentNode:
		return soap_out_tree__getParentNode(soap, tag, id, (const struct tree__getParentNode *)ptr, "tree:getParentNode");
	case SOAP_TYPE_tree__getCheckPointData:
		return soap_out_tree__getCheckPointData(soap, tag, id, (const struct tree__getCheckPointData *)ptr, "tree:getCheckPointData");
	case SOAP_TYPE_tree__requestTerminationBefore:
		return soap_out_tree__requestTerminationBefore(soap, tag, id, (const struct tree__requestTerminationBefore *)ptr, "tree:requestTerminationBefore");
	case SOAP_TYPE_tree__getSteeringCommands:
		return soap_out_tree__getSteeringCommands(soap, tag, id, (const struct tree__getSteeringCommands *)ptr, "tree:getSteeringCommands");
	case SOAP_TYPE_tree__destroy:
		return soap_out_tree__destroy(soap, tag, id, (const struct tree__destroy *)ptr, "tree:destroy");
	case SOAP_TYPE_tree__setCheckPointData:
		return soap_out_tree__setCheckPointData(soap, tag, id, (const struct tree__setCheckPointData *)ptr, "tree:setCheckPointData");
	case SOAP_TYPE_tree__findServiceData:
		return soap_out_tree__findServiceData(soap, tag, id, (const struct tree__findServiceData *)ptr, "tree:findServiceData");
	case SOAP_TYPE_tree__getInputFile:
		return soap_out_tree__getInputFile(soap, tag, id, (const struct tree__getInputFile *)ptr, "tree:getInputFile");
	case SOAP_TYPE_tree__getChildNodes:
		return soap_out_tree__getChildNodes(soap, tag, id, (const struct tree__getChildNodes *)ptr, "tree:getChildNodes");
	case SOAP_TYPE_tree__requestTerminationAfter:
		return soap_out_tree__requestTerminationAfter(soap, tag, id, (const struct tree__requestTerminationAfter *)ptr, "tree:requestTerminationAfter");
	case SOAP_TYPE_fact__requestTerminationAfter:
		return soap_out_fact__requestTerminationAfter(soap, tag, id, (const struct fact__requestTerminationAfter *)ptr, "fact:requestTerminationAfter");
	case SOAP_TYPE_fact__requestTerminationBefore:
		return soap_out_fact__requestTerminationBefore(soap, tag, id, (const struct fact__requestTerminationBefore *)ptr, "fact:requestTerminationBefore");
	case SOAP_TYPE_fact__getActiveTrees:
		return soap_out_fact__getActiveTrees(soap, tag, id, (const struct fact__getActiveTrees *)ptr, "fact:getActiveTrees");
	case SOAP_TYPE_fact__findServiceData:
		return soap_out_fact__findServiceData(soap, tag, id, (const struct fact__findServiceData *)ptr, "fact:findServiceData");
	case SOAP_TYPE_fact__destroy:
		return soap_out_fact__destroy(soap, tag, id, (const struct fact__destroy *)ptr, "fact:destroy");
	case SOAP_TYPE_fact__findByHandle:
		return soap_out_fact__findByHandle(soap, tag, id, (const struct fact__findByHandle *)ptr, "fact:findByHandle");
	case SOAP_TYPE_fact__createNewTree:
		return soap_out_fact__createNewTree(soap, tag, id, (const struct fact__createNewTree *)ptr, "fact:createNewTree");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char**)&ptr, "QName");
	case SOAP_TYPE_PointerTotree__addNodeResponse:
		return soap_out_PointerTotree__addNodeResponse(soap, tag, id, (tree__addNodeResponse *const*)ptr, "tree:addNodeResponse");
	case SOAP_TYPE_PointerTotree__getParentNodeResponse:
		return soap_out_PointerTotree__getParentNodeResponse(soap, tag, id, (tree__getParentNodeResponse *const*)ptr, "tree:getParentNodeResponse");
	case SOAP_TYPE_PointerTotree__getCheckPointDataResponse:
		return soap_out_PointerTotree__getCheckPointDataResponse(soap, tag, id, (tree__getCheckPointDataResponse *const*)ptr, "tree:getCheckPointDataResponse");
	case SOAP_TYPE_PointerTotree__requestTerminationBeforeResponse:
		return soap_out_PointerTotree__requestTerminationBeforeResponse(soap, tag, id, (tree__requestTerminationBeforeResponse *const*)ptr, "tree:requestTerminationBeforeResponse");
	case SOAP_TYPE_PointerTotree__getSteeringCommandsResponse:
		return soap_out_PointerTotree__getSteeringCommandsResponse(soap, tag, id, (tree__getSteeringCommandsResponse *const*)ptr, "tree:getSteeringCommandsResponse");
	case SOAP_TYPE_PointerTotree__destroyResponse:
		return soap_out_PointerTotree__destroyResponse(soap, tag, id, (tree__destroyResponse *const*)ptr, "tree:destroyResponse");
	case SOAP_TYPE_PointerTotree__setCheckPointDataResponse:
		return soap_out_PointerTotree__setCheckPointDataResponse(soap, tag, id, (tree__setCheckPointDataResponse *const*)ptr, "tree:setCheckPointDataResponse");
	case SOAP_TYPE_PointerTotree__findServiceDataResponse:
		return soap_out_PointerTotree__findServiceDataResponse(soap, tag, id, (tree__findServiceDataResponse *const*)ptr, "tree:findServiceDataResponse");
	case SOAP_TYPE_PointerTotree__getInputFileResponse:
		return soap_out_PointerTotree__getInputFileResponse(soap, tag, id, (tree__getInputFileResponse *const*)ptr, "tree:getInputFileResponse");
	case SOAP_TYPE_PointerTotree__getChildNodesResponse:
		return soap_out_PointerTotree__getChildNodesResponse(soap, tag, id, (tree__getChildNodesResponse *const*)ptr, "tree:getChildNodesResponse");
	case SOAP_TYPE_PointerTotree__requestTerminationAfterResponse:
		return soap_out_PointerTotree__requestTerminationAfterResponse(soap, tag, id, (tree__requestTerminationAfterResponse *const*)ptr, "tree:requestTerminationAfterResponse");
	case SOAP_TYPE_PointerTofact__requestTerminationAfterResponse:
		return soap_out_PointerTofact__requestTerminationAfterResponse(soap, tag, id, (fact__requestTerminationAfterResponse *const*)ptr, "fact:requestTerminationAfterResponse");
	case SOAP_TYPE_PointerTofact__requestTerminationBeforeResponse:
		return soap_out_PointerTofact__requestTerminationBeforeResponse(soap, tag, id, (fact__requestTerminationBeforeResponse *const*)ptr, "fact:requestTerminationBeforeResponse");
	case SOAP_TYPE_PointerTofact__getActiveTreesResponse:
		return soap_out_PointerTofact__getActiveTreesResponse(soap, tag, id, (fact__getActiveTreesResponse *const*)ptr, "fact:getActiveTreesResponse");
	case SOAP_TYPE_PointerTofact__findServiceDataResponse:
		return soap_out_PointerTofact__findServiceDataResponse(soap, tag, id, (fact__findServiceDataResponse *const*)ptr, "fact:findServiceDataResponse");
	case SOAP_TYPE_PointerTofact__destroyResponse:
		return soap_out_PointerTofact__destroyResponse(soap, tag, id, (fact__destroyResponse *const*)ptr, "fact:destroyResponse");
	case SOAP_TYPE_PointerTofact__findByHandleResponse:
		return soap_out_PointerTofact__findByHandleResponse(soap, tag, id, (fact__findByHandleResponse *const*)ptr, "fact:findByHandleResponse");
	case SOAP_TYPE_PointerTofact__createNewTreeResponse:
		return soap_out_PointerTofact__createNewTreeResponse(soap, tag, id, (fact__createNewTreeResponse *const*)ptr, "fact:createNewTreeResponse");
	case SOAP_TYPE_xsd__string:
		return soap_out_string(soap, tag, id, (char**)&ptr, "xsd:string");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char**)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifndef WITH_LEANER
SOAP_FMAC3 int SOAP_FMAC4 soap_getattachments(struct soap *soap)
{
	if (!(soap->mode & SOAP_ENC_DIME))
		return SOAP_OK;
	while (soap->dime_flags & SOAP_DIME_CF)
	{	if (soap_getdimehdr(soap))
			return soap->error;
		if (soap_move(soap, soap->dime_size))
			return soap->error = SOAP_EOF;
	}
	if (soap_move(soap, ((soap->dime_size+3)&(~3))-soap_tell(soap)))
		return soap->error = SOAP_EOF;
	for (;;)
	{	if (soap_getdime(soap) || !soap->dime_id)
			break;
		switch (soap_lookup_type(soap, soap->dime_id))
		{
		case SOAP_TYPE__QName:
		{	char ** a;
			a = (char **)soap_id_enter(soap, soap->dime_id, NULL, SOAP_TYPE__QName, sizeof(char *), 0);
			if (a)
				*a = soap->dime_ptr;
			break;
		}
		case SOAP_TYPE_xsd__string:
		{	char ** a;
			a = (char **)soap_id_enter(soap, soap->dime_id, NULL, SOAP_TYPE_xsd__string, sizeof(char *), 0);
			if (a)
				*a = soap->dime_ptr;
			break;
		}
		case SOAP_TYPE_string:
		{	char ** a;
			a = (char **)soap_id_enter(soap, soap->dime_id, NULL, SOAP_TYPE_string, sizeof(char *), 0);
			if (a)
				*a = soap->dime_ptr;
			break;
		}
		default:
			soap->error = SOAP_DIME_ERROR;
		}
		if (soap->error)
			break;
	}
	if (soap->error == SOAP_EOD)
		soap->error = SOAP_OK;
	return soap->error;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putattachments(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (!(soap->mode & SOAP_ENC_DIME))
		return SOAP_OK;
	for (i = 0; i < SOAP_PTRHASH; i++)
		for (pp = soap->pht[i]; pp; pp = pp->next)
			if (pp->mark2 == 3)
				switch (pp->type)
				{
				}
		
	return SOAP_OK;
}
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{
	switch (t)
	{
	case SOAP_TYPE_fact__requestTerminationBeforeResponse:
		return (void*)soap_instantiate_fact__requestTerminationBeforeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fact__findServiceDataResponse:
		return (void*)soap_instantiate_fact__findServiceDataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fact__findByHandleResponse:
		return (void*)soap_instantiate_fact__findByHandleResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fact__getActiveTreesResponse:
		return (void*)soap_instantiate_fact__getActiveTreesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fact__createNewTreeResponse:
		return (void*)soap_instantiate_fact__createNewTreeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fact__requestTerminationAfterResponse:
		return (void*)soap_instantiate_fact__requestTerminationAfterResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_fact__destroyResponse:
		return (void*)soap_instantiate_fact__destroyResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tree__getParentNodeResponse:
		return (void*)soap_instantiate_tree__getParentNodeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tree__requestTerminationAfterResponse:
		return (void*)soap_instantiate_tree__requestTerminationAfterResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tree__addNodeResponse:
		return (void*)soap_instantiate_tree__addNodeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tree__getCheckPointDataResponse:
		return (void*)soap_instantiate_tree__getCheckPointDataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tree__findServiceDataResponse:
		return (void*)soap_instantiate_tree__findServiceDataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tree__setCheckPointDataResponse:
		return (void*)soap_instantiate_tree__setCheckPointDataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tree__getChildNodesResponse:
		return (void*)soap_instantiate_tree__getChildNodesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tree__requestTerminationBeforeResponse:
		return (void*)soap_instantiate_tree__requestTerminationBeforeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tree__getSteeringCommandsResponse:
		return (void*)soap_instantiate_tree__getSteeringCommandsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tree__getInputFileResponse:
		return (void*)soap_instantiate_tree__getInputFileResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tree__destroyResponse:
		return (void*)soap_instantiate_tree__destroyResponse(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_fact__requestTerminationBeforeResponse:
		if (p->size < 0)
			delete (fact__requestTerminationBeforeResponse*)p->ptr;
		else
			delete[] (fact__requestTerminationBeforeResponse*)p->ptr;
		break;
	case SOAP_TYPE_fact__findServiceDataResponse:
		if (p->size < 0)
			delete (fact__findServiceDataResponse*)p->ptr;
		else
			delete[] (fact__findServiceDataResponse*)p->ptr;
		break;
	case SOAP_TYPE_fact__findByHandleResponse:
		if (p->size < 0)
			delete (fact__findByHandleResponse*)p->ptr;
		else
			delete[] (fact__findByHandleResponse*)p->ptr;
		break;
	case SOAP_TYPE_fact__getActiveTreesResponse:
		if (p->size < 0)
			delete (fact__getActiveTreesResponse*)p->ptr;
		else
			delete[] (fact__getActiveTreesResponse*)p->ptr;
		break;
	case SOAP_TYPE_fact__createNewTreeResponse:
		if (p->size < 0)
			delete (fact__createNewTreeResponse*)p->ptr;
		else
			delete[] (fact__createNewTreeResponse*)p->ptr;
		break;
	case SOAP_TYPE_fact__requestTerminationAfterResponse:
		if (p->size < 0)
			delete (fact__requestTerminationAfterResponse*)p->ptr;
		else
			delete[] (fact__requestTerminationAfterResponse*)p->ptr;
		break;
	case SOAP_TYPE_fact__destroyResponse:
		if (p->size < 0)
			delete (fact__destroyResponse*)p->ptr;
		else
			delete[] (fact__destroyResponse*)p->ptr;
		break;
	case SOAP_TYPE_tree__getParentNodeResponse:
		if (p->size < 0)
			delete (tree__getParentNodeResponse*)p->ptr;
		else
			delete[] (tree__getParentNodeResponse*)p->ptr;
		break;
	case SOAP_TYPE_tree__requestTerminationAfterResponse:
		if (p->size < 0)
			delete (tree__requestTerminationAfterResponse*)p->ptr;
		else
			delete[] (tree__requestTerminationAfterResponse*)p->ptr;
		break;
	case SOAP_TYPE_tree__addNodeResponse:
		if (p->size < 0)
			delete (tree__addNodeResponse*)p->ptr;
		else
			delete[] (tree__addNodeResponse*)p->ptr;
		break;
	case SOAP_TYPE_tree__getCheckPointDataResponse:
		if (p->size < 0)
			delete (tree__getCheckPointDataResponse*)p->ptr;
		else
			delete[] (tree__getCheckPointDataResponse*)p->ptr;
		break;
	case SOAP_TYPE_tree__findServiceDataResponse:
		if (p->size < 0)
			delete (tree__findServiceDataResponse*)p->ptr;
		else
			delete[] (tree__findServiceDataResponse*)p->ptr;
		break;
	case SOAP_TYPE_tree__setCheckPointDataResponse:
		if (p->size < 0)
			delete (tree__setCheckPointDataResponse*)p->ptr;
		else
			delete[] (tree__setCheckPointDataResponse*)p->ptr;
		break;
	case SOAP_TYPE_tree__getChildNodesResponse:
		if (p->size < 0)
			delete (tree__getChildNodesResponse*)p->ptr;
		else
			delete[] (tree__getChildNodesResponse*)p->ptr;
		break;
	case SOAP_TYPE_tree__requestTerminationBeforeResponse:
		if (p->size < 0)
			delete (tree__requestTerminationBeforeResponse*)p->ptr;
		else
			delete[] (tree__requestTerminationBeforeResponse*)p->ptr;
		break;
	case SOAP_TYPE_tree__getSteeringCommandsResponse:
		if (p->size < 0)
			delete (tree__getSteeringCommandsResponse*)p->ptr;
		else
			delete[] (tree__getSteeringCommandsResponse*)p->ptr;
		break;
	case SOAP_TYPE_tree__getInputFileResponse:
		if (p->size < 0)
			delete (tree__getInputFileResponse*)p->ptr;
		else
			delete[] (tree__getInputFileResponse*)p->ptr;
		break;
	case SOAP_TYPE_tree__destroyResponse:
		if (p->size < 0)
			delete (tree__destroyResponse*)p->ptr;
		else
			delete[] (tree__destroyResponse*)p->ptr;
		break;
	}
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	struct soap_ilist *ip;
	DBGLOG(TEST,SOAP_MESSAGE(fdebug, "Class id enter id='%s' t=%d loc=%p type='%s' arrayType='%s'\n", id, t, p, type?type:"", arrayType?arrayType:""));
	soap->alloced = 0;
	if (!*id)
	{	if (!p)
			return soap_instantiate(soap, t, type, arrayType, NULL);
		else
			return p;
	}
	ip = soap_lookup(soap, id);
	if (!ip)
	{	ip = soap_enter(soap, id);
		ip->type = t;
		ip->link = NULL;
		ip->copy = NULL;
		ip->clist = NULL;
		if (!p)
			p = soap_instantiate(soap, t, type, arrayType, &n);
		ip->ptr = p;
		ip->size = n;
		ip->level = 0;
	}
	else if (ip->ptr)
	{	if (p)
		{	soap->error = SOAP_MULTI_ID;
			return NULL;
		}
	}
	else
	{	if (!p)
			p = soap_instantiate(soap, t, type, arrayType, &n);
		ip->ptr = p;
		ip->size = n;
		ip->level = 0;
		if (!soap->blist)
			soap_resolve_ptr(ip);
	}
	return ip->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_byte(struct soap *soap, char const*a)
{
	soap_reference(soap, a, SOAP_TYPE_byte);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, char *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_byte);
	soap_out_byte(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	return soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_int(struct soap *soap, int const*a)
{
	soap_reference(soap, a, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, int *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_int);
	soap_out_int(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	return soap_inint(soap, tag, a, type, SOAP_TYPE_int);
}

void tree__destroyResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_tree__destroyResponse))
		this->soap_mark(soap);
}

void tree__destroyResponse::soap_mark(struct soap *soap) const
{
}

void tree__destroyResponse::soap_default(struct soap *soap)
{
}

int tree__destroyResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_tree__destroyResponse);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int tree__destroyResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tree__destroyResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tree__destroyResponse(struct soap *soap, const char *tag, int id, const tree__destroyResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tree__destroyResponse), "tree:destroyResponse");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *tree__destroyResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tree__destroyResponse(soap, this, tag, type);
}

SOAP_FMAC3 tree__destroyResponse * SOAP_FMAC4 soap_get_tree__destroyResponse(struct soap *soap, tree__destroyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tree__destroyResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *tree__destroyResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tree__destroyResponse(soap, tag, this, type);
}

SOAP_FMAC3 tree__destroyResponse * SOAP_FMAC4 soap_in_tree__destroyResponse(struct soap *soap, const char *tag, tree__destroyResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (tree__destroyResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tree__destroyResponse, sizeof(tree__destroyResponse), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_tree__destroyResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (tree__destroyResponse *)a->soap_in(soap, tag, type);
			}
		};
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (tree__destroyResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tree__destroyResponse, sizeof(tree__destroyResponse), soap->type, soap->arrayType), SOAP_TYPE_tree__destroyResponse, sizeof(tree__destroyResponse));
		if (soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 tree__destroyResponse * SOAP_FMAC6 soap_new_tree__destroyResponse(struct soap *soap, int n)
{	return soap_instantiate_tree__destroyResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_tree__destroyResponse(struct soap *soap, tree__destroyResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 tree__destroyResponse * SOAP_FMAC6 soap_instantiate_tree__destroyResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tree__destroyResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tree__destroyResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new tree__destroyResponse;
		if (size)
			*size = sizeof(tree__destroyResponse);
	}
	else
	{	cp->ptr = (void*)new tree__destroyResponse[n];
		if (size)
			*size = n * sizeof(tree__destroyResponse);
	}
	return (tree__destroyResponse*)cp->ptr;
}

void tree__getInputFileResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_tree__getInputFileResponse))
		this->soap_mark(soap);
}

void tree__getInputFileResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((tree__getInputFileResponse*)this)->_getInputFileReturn, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &((tree__getInputFileResponse*)this)->_getInputFileReturn);
}

void tree__getInputFileResponse::soap_default(struct soap *soap)
{
	soap_default_xsd__string(soap, &((tree__getInputFileResponse*)this)->_getInputFileReturn);
}

int tree__getInputFileResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_tree__getInputFileResponse);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int tree__getInputFileResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tree__getInputFileResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tree__getInputFileResponse(struct soap *soap, const char *tag, int id, const tree__getInputFileResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tree__getInputFileResponse), "tree:getInputFileResponse");
	soap_out_xsd__string(soap, "getInputFileReturn", -1, &(((tree__getInputFileResponse*)a)->_getInputFileReturn), "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *tree__getInputFileResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tree__getInputFileResponse(soap, this, tag, type);
}

SOAP_FMAC3 tree__getInputFileResponse * SOAP_FMAC4 soap_get_tree__getInputFileResponse(struct soap *soap, tree__getInputFileResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tree__getInputFileResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *tree__getInputFileResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tree__getInputFileResponse(soap, tag, this, type);
}

SOAP_FMAC3 tree__getInputFileResponse * SOAP_FMAC4 soap_in_tree__getInputFileResponse(struct soap *soap, const char *tag, tree__getInputFileResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (tree__getInputFileResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tree__getInputFileResponse, sizeof(tree__getInputFileResponse), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_tree__getInputFileResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (tree__getInputFileResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag__getInputFileReturn1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag__getInputFileReturn1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &(((tree__getInputFileResponse*)a)->_getInputFileReturn), "xsd:string"))
				{	soap_flag__getInputFileReturn1 = 0;
					continue;
				}

			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (tree__getInputFileResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tree__getInputFileResponse, sizeof(tree__getInputFileResponse), soap->type, soap->arrayType), SOAP_TYPE_tree__getInputFileResponse, sizeof(tree__getInputFileResponse));
		if (soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 tree__getInputFileResponse * SOAP_FMAC6 soap_new_tree__getInputFileResponse(struct soap *soap, int n)
{	return soap_instantiate_tree__getInputFileResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_tree__getInputFileResponse(struct soap *soap, tree__getInputFileResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 tree__getInputFileResponse * SOAP_FMAC6 soap_instantiate_tree__getInputFileResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tree__getInputFileResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tree__getInputFileResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new tree__getInputFileResponse;
		if (size)
			*size = sizeof(tree__getInputFileResponse);
	}
	else
	{	cp->ptr = (void*)new tree__getInputFileResponse[n];
		if (size)
			*size = n * sizeof(tree__getInputFileResponse);
	}
	return (tree__getInputFileResponse*)cp->ptr;
}

void tree__getSteeringCommandsResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_tree__getSteeringCommandsResponse))
		this->soap_mark(soap);
}

void tree__getSteeringCommandsResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((tree__getSteeringCommandsResponse*)this)->_getSteeringCommandsReturn, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &((tree__getSteeringCommandsResponse*)this)->_getSteeringCommandsReturn);
}

void tree__getSteeringCommandsResponse::soap_default(struct soap *soap)
{
	soap_default_xsd__string(soap, &((tree__getSteeringCommandsResponse*)this)->_getSteeringCommandsReturn);
}

int tree__getSteeringCommandsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_tree__getSteeringCommandsResponse);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int tree__getSteeringCommandsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tree__getSteeringCommandsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tree__getSteeringCommandsResponse(struct soap *soap, const char *tag, int id, const tree__getSteeringCommandsResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tree__getSteeringCommandsResponse), "tree:getSteeringCommandsResponse");
	soap_out_xsd__string(soap, "getSteeringCommandsReturn", -1, &(((tree__getSteeringCommandsResponse*)a)->_getSteeringCommandsReturn), "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *tree__getSteeringCommandsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tree__getSteeringCommandsResponse(soap, this, tag, type);
}

SOAP_FMAC3 tree__getSteeringCommandsResponse * SOAP_FMAC4 soap_get_tree__getSteeringCommandsResponse(struct soap *soap, tree__getSteeringCommandsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tree__getSteeringCommandsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *tree__getSteeringCommandsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tree__getSteeringCommandsResponse(soap, tag, this, type);
}

SOAP_FMAC3 tree__getSteeringCommandsResponse * SOAP_FMAC4 soap_in_tree__getSteeringCommandsResponse(struct soap *soap, const char *tag, tree__getSteeringCommandsResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (tree__getSteeringCommandsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tree__getSteeringCommandsResponse, sizeof(tree__getSteeringCommandsResponse), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_tree__getSteeringCommandsResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (tree__getSteeringCommandsResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag__getSteeringCommandsReturn1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag__getSteeringCommandsReturn1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &(((tree__getSteeringCommandsResponse*)a)->_getSteeringCommandsReturn), "xsd:string"))
				{	soap_flag__getSteeringCommandsReturn1 = 0;
					continue;
				}

			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (tree__getSteeringCommandsResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tree__getSteeringCommandsResponse, sizeof(tree__getSteeringCommandsResponse), soap->type, soap->arrayType), SOAP_TYPE_tree__getSteeringCommandsResponse, sizeof(tree__getSteeringCommandsResponse));
		if (soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 tree__getSteeringCommandsResponse * SOAP_FMAC6 soap_new_tree__getSteeringCommandsResponse(struct soap *soap, int n)
{	return soap_instantiate_tree__getSteeringCommandsResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_tree__getSteeringCommandsResponse(struct soap *soap, tree__getSteeringCommandsResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 tree__getSteeringCommandsResponse * SOAP_FMAC6 soap_instantiate_tree__getSteeringCommandsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tree__getSteeringCommandsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tree__getSteeringCommandsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new tree__getSteeringCommandsResponse;
		if (size)
			*size = sizeof(tree__getSteeringCommandsResponse);
	}
	else
	{	cp->ptr = (void*)new tree__getSteeringCommandsResponse[n];
		if (size)
			*size = n * sizeof(tree__getSteeringCommandsResponse);
	}
	return (tree__getSteeringCommandsResponse*)cp->ptr;
}

void tree__requestTerminationBeforeResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_tree__requestTerminationBeforeResponse))
		this->soap_mark(soap);
}

void tree__requestTerminationBeforeResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((tree__requestTerminationBeforeResponse*)this)->_requestTerminationBeforeReturn, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &((tree__requestTerminationBeforeResponse*)this)->_requestTerminationBeforeReturn);
}

void tree__requestTerminationBeforeResponse::soap_default(struct soap *soap)
{
	soap_default_xsd__string(soap, &((tree__requestTerminationBeforeResponse*)this)->_requestTerminationBeforeReturn);
}

int tree__requestTerminationBeforeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_tree__requestTerminationBeforeResponse);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int tree__requestTerminationBeforeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tree__requestTerminationBeforeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tree__requestTerminationBeforeResponse(struct soap *soap, const char *tag, int id, const tree__requestTerminationBeforeResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tree__requestTerminationBeforeResponse), "tree:requestTerminationBeforeResponse");
	soap_out_xsd__string(soap, "requestTerminationBeforeReturn", -1, &(((tree__requestTerminationBeforeResponse*)a)->_requestTerminationBeforeReturn), "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *tree__requestTerminationBeforeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tree__requestTerminationBeforeResponse(soap, this, tag, type);
}

SOAP_FMAC3 tree__requestTerminationBeforeResponse * SOAP_FMAC4 soap_get_tree__requestTerminationBeforeResponse(struct soap *soap, tree__requestTerminationBeforeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tree__requestTerminationBeforeResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *tree__requestTerminationBeforeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tree__requestTerminationBeforeResponse(soap, tag, this, type);
}

SOAP_FMAC3 tree__requestTerminationBeforeResponse * SOAP_FMAC4 soap_in_tree__requestTerminationBeforeResponse(struct soap *soap, const char *tag, tree__requestTerminationBeforeResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (tree__requestTerminationBeforeResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tree__requestTerminationBeforeResponse, sizeof(tree__requestTerminationBeforeResponse), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_tree__requestTerminationBeforeResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (tree__requestTerminationBeforeResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag__requestTerminationBeforeReturn1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag__requestTerminationBeforeReturn1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &(((tree__requestTerminationBeforeResponse*)a)->_requestTerminationBeforeReturn), "xsd:string"))
				{	soap_flag__requestTerminationBeforeReturn1 = 0;
					continue;
				}

			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (tree__requestTerminationBeforeResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tree__requestTerminationBeforeResponse, sizeof(tree__requestTerminationBeforeResponse), soap->type, soap->arrayType), SOAP_TYPE_tree__requestTerminationBeforeResponse, sizeof(tree__requestTerminationBeforeResponse));
		if (soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 tree__requestTerminationBeforeResponse * SOAP_FMAC6 soap_new_tree__requestTerminationBeforeResponse(struct soap *soap, int n)
{	return soap_instantiate_tree__requestTerminationBeforeResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_tree__requestTerminationBeforeResponse(struct soap *soap, tree__requestTerminationBeforeResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 tree__requestTerminationBeforeResponse * SOAP_FMAC6 soap_instantiate_tree__requestTerminationBeforeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tree__requestTerminationBeforeResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tree__requestTerminationBeforeResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new tree__requestTerminationBeforeResponse;
		if (size)
			*size = sizeof(tree__requestTerminationBeforeResponse);
	}
	else
	{	cp->ptr = (void*)new tree__requestTerminationBeforeResponse[n];
		if (size)
			*size = n * sizeof(tree__requestTerminationBeforeResponse);
	}
	return (tree__requestTerminationBeforeResponse*)cp->ptr;
}

void tree__getChildNodesResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_tree__getChildNodesResponse))
		this->soap_mark(soap);
}

void tree__getChildNodesResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((tree__getChildNodesResponse*)this)->_getChildNodesReturn, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &((tree__getChildNodesResponse*)this)->_getChildNodesReturn);
}

void tree__getChildNodesResponse::soap_default(struct soap *soap)
{
	soap_default_xsd__string(soap, &((tree__getChildNodesResponse*)this)->_getChildNodesReturn);
}

int tree__getChildNodesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_tree__getChildNodesResponse);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int tree__getChildNodesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tree__getChildNodesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tree__getChildNodesResponse(struct soap *soap, const char *tag, int id, const tree__getChildNodesResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tree__getChildNodesResponse), "tree:getChildNodesResponse");
	soap_out_xsd__string(soap, "getChildNodesReturn", -1, &(((tree__getChildNodesResponse*)a)->_getChildNodesReturn), "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *tree__getChildNodesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tree__getChildNodesResponse(soap, this, tag, type);
}

SOAP_FMAC3 tree__getChildNodesResponse * SOAP_FMAC4 soap_get_tree__getChildNodesResponse(struct soap *soap, tree__getChildNodesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tree__getChildNodesResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *tree__getChildNodesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tree__getChildNodesResponse(soap, tag, this, type);
}

SOAP_FMAC3 tree__getChildNodesResponse * SOAP_FMAC4 soap_in_tree__getChildNodesResponse(struct soap *soap, const char *tag, tree__getChildNodesResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (tree__getChildNodesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tree__getChildNodesResponse, sizeof(tree__getChildNodesResponse), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_tree__getChildNodesResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (tree__getChildNodesResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag__getChildNodesReturn1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag__getChildNodesReturn1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &(((tree__getChildNodesResponse*)a)->_getChildNodesReturn), "xsd:string"))
				{	soap_flag__getChildNodesReturn1 = 0;
					continue;
				}

			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (tree__getChildNodesResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tree__getChildNodesResponse, sizeof(tree__getChildNodesResponse), soap->type, soap->arrayType), SOAP_TYPE_tree__getChildNodesResponse, sizeof(tree__getChildNodesResponse));
		if (soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 tree__getChildNodesResponse * SOAP_FMAC6 soap_new_tree__getChildNodesResponse(struct soap *soap, int n)
{	return soap_instantiate_tree__getChildNodesResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_tree__getChildNodesResponse(struct soap *soap, tree__getChildNodesResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 tree__getChildNodesResponse * SOAP_FMAC6 soap_instantiate_tree__getChildNodesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tree__getChildNodesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tree__getChildNodesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new tree__getChildNodesResponse;
		if (size)
			*size = sizeof(tree__getChildNodesResponse);
	}
	else
	{	cp->ptr = (void*)new tree__getChildNodesResponse[n];
		if (size)
			*size = n * sizeof(tree__getChildNodesResponse);
	}
	return (tree__getChildNodesResponse*)cp->ptr;
}

void tree__setCheckPointDataResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_tree__setCheckPointDataResponse))
		this->soap_mark(soap);
}

void tree__setCheckPointDataResponse::soap_mark(struct soap *soap) const
{
}

void tree__setCheckPointDataResponse::soap_default(struct soap *soap)
{
}

int tree__setCheckPointDataResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_tree__setCheckPointDataResponse);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int tree__setCheckPointDataResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tree__setCheckPointDataResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tree__setCheckPointDataResponse(struct soap *soap, const char *tag, int id, const tree__setCheckPointDataResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tree__setCheckPointDataResponse), "tree:setCheckPointDataResponse");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *tree__setCheckPointDataResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tree__setCheckPointDataResponse(soap, this, tag, type);
}

SOAP_FMAC3 tree__setCheckPointDataResponse * SOAP_FMAC4 soap_get_tree__setCheckPointDataResponse(struct soap *soap, tree__setCheckPointDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tree__setCheckPointDataResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *tree__setCheckPointDataResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tree__setCheckPointDataResponse(soap, tag, this, type);
}

SOAP_FMAC3 tree__setCheckPointDataResponse * SOAP_FMAC4 soap_in_tree__setCheckPointDataResponse(struct soap *soap, const char *tag, tree__setCheckPointDataResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (tree__setCheckPointDataResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tree__setCheckPointDataResponse, sizeof(tree__setCheckPointDataResponse), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_tree__setCheckPointDataResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (tree__setCheckPointDataResponse *)a->soap_in(soap, tag, type);
			}
		};
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (tree__setCheckPointDataResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tree__setCheckPointDataResponse, sizeof(tree__setCheckPointDataResponse), soap->type, soap->arrayType), SOAP_TYPE_tree__setCheckPointDataResponse, sizeof(tree__setCheckPointDataResponse));
		if (soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 tree__setCheckPointDataResponse * SOAP_FMAC6 soap_new_tree__setCheckPointDataResponse(struct soap *soap, int n)
{	return soap_instantiate_tree__setCheckPointDataResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_tree__setCheckPointDataResponse(struct soap *soap, tree__setCheckPointDataResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 tree__setCheckPointDataResponse * SOAP_FMAC6 soap_instantiate_tree__setCheckPointDataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tree__setCheckPointDataResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tree__setCheckPointDataResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new tree__setCheckPointDataResponse;
		if (size)
			*size = sizeof(tree__setCheckPointDataResponse);
	}
	else
	{	cp->ptr = (void*)new tree__setCheckPointDataResponse[n];
		if (size)
			*size = n * sizeof(tree__setCheckPointDataResponse);
	}
	return (tree__setCheckPointDataResponse*)cp->ptr;
}

void tree__findServiceDataResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_tree__findServiceDataResponse))
		this->soap_mark(soap);
}

void tree__findServiceDataResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((tree__findServiceDataResponse*)this)->_findServiceDataReturn, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &((tree__findServiceDataResponse*)this)->_findServiceDataReturn);
}

void tree__findServiceDataResponse::soap_default(struct soap *soap)
{
	soap_default_xsd__string(soap, &((tree__findServiceDataResponse*)this)->_findServiceDataReturn);
}

int tree__findServiceDataResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_tree__findServiceDataResponse);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int tree__findServiceDataResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tree__findServiceDataResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tree__findServiceDataResponse(struct soap *soap, const char *tag, int id, const tree__findServiceDataResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tree__findServiceDataResponse), "tree:findServiceDataResponse");
	soap_out_xsd__string(soap, "findServiceDataReturn", -1, &(((tree__findServiceDataResponse*)a)->_findServiceDataReturn), "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *tree__findServiceDataResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tree__findServiceDataResponse(soap, this, tag, type);
}

SOAP_FMAC3 tree__findServiceDataResponse * SOAP_FMAC4 soap_get_tree__findServiceDataResponse(struct soap *soap, tree__findServiceDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tree__findServiceDataResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *tree__findServiceDataResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tree__findServiceDataResponse(soap, tag, this, type);
}

SOAP_FMAC3 tree__findServiceDataResponse * SOAP_FMAC4 soap_in_tree__findServiceDataResponse(struct soap *soap, const char *tag, tree__findServiceDataResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (tree__findServiceDataResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tree__findServiceDataResponse, sizeof(tree__findServiceDataResponse), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_tree__findServiceDataResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (tree__findServiceDataResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag__findServiceDataReturn1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag__findServiceDataReturn1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &(((tree__findServiceDataResponse*)a)->_findServiceDataReturn), "xsd:string"))
				{	soap_flag__findServiceDataReturn1 = 0;
					continue;
				}

			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (tree__findServiceDataResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tree__findServiceDataResponse, sizeof(tree__findServiceDataResponse), soap->type, soap->arrayType), SOAP_TYPE_tree__findServiceDataResponse, sizeof(tree__findServiceDataResponse));
		if (soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 tree__findServiceDataResponse * SOAP_FMAC6 soap_new_tree__findServiceDataResponse(struct soap *soap, int n)
{	return soap_instantiate_tree__findServiceDataResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_tree__findServiceDataResponse(struct soap *soap, tree__findServiceDataResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 tree__findServiceDataResponse * SOAP_FMAC6 soap_instantiate_tree__findServiceDataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tree__findServiceDataResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tree__findServiceDataResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new tree__findServiceDataResponse;
		if (size)
			*size = sizeof(tree__findServiceDataResponse);
	}
	else
	{	cp->ptr = (void*)new tree__findServiceDataResponse[n];
		if (size)
			*size = n * sizeof(tree__findServiceDataResponse);
	}
	return (tree__findServiceDataResponse*)cp->ptr;
}

void tree__getCheckPointDataResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_tree__getCheckPointDataResponse))
		this->soap_mark(soap);
}

void tree__getCheckPointDataResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((tree__getCheckPointDataResponse*)this)->_getCheckPointDataReturn, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &((tree__getCheckPointDataResponse*)this)->_getCheckPointDataReturn);
}

void tree__getCheckPointDataResponse::soap_default(struct soap *soap)
{
	soap_default_xsd__string(soap, &((tree__getCheckPointDataResponse*)this)->_getCheckPointDataReturn);
}

int tree__getCheckPointDataResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_tree__getCheckPointDataResponse);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int tree__getCheckPointDataResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tree__getCheckPointDataResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tree__getCheckPointDataResponse(struct soap *soap, const char *tag, int id, const tree__getCheckPointDataResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tree__getCheckPointDataResponse), "tree:getCheckPointDataResponse");
	soap_out_xsd__string(soap, "getCheckPointDataReturn", -1, &(((tree__getCheckPointDataResponse*)a)->_getCheckPointDataReturn), "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *tree__getCheckPointDataResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tree__getCheckPointDataResponse(soap, this, tag, type);
}

SOAP_FMAC3 tree__getCheckPointDataResponse * SOAP_FMAC4 soap_get_tree__getCheckPointDataResponse(struct soap *soap, tree__getCheckPointDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tree__getCheckPointDataResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *tree__getCheckPointDataResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tree__getCheckPointDataResponse(soap, tag, this, type);
}

SOAP_FMAC3 tree__getCheckPointDataResponse * SOAP_FMAC4 soap_in_tree__getCheckPointDataResponse(struct soap *soap, const char *tag, tree__getCheckPointDataResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (tree__getCheckPointDataResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tree__getCheckPointDataResponse, sizeof(tree__getCheckPointDataResponse), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_tree__getCheckPointDataResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (tree__getCheckPointDataResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag__getCheckPointDataReturn1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag__getCheckPointDataReturn1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &(((tree__getCheckPointDataResponse*)a)->_getCheckPointDataReturn), "xsd:string"))
				{	soap_flag__getCheckPointDataReturn1 = 0;
					continue;
				}

			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (tree__getCheckPointDataResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tree__getCheckPointDataResponse, sizeof(tree__getCheckPointDataResponse), soap->type, soap->arrayType), SOAP_TYPE_tree__getCheckPointDataResponse, sizeof(tree__getCheckPointDataResponse));
		if (soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 tree__getCheckPointDataResponse * SOAP_FMAC6 soap_new_tree__getCheckPointDataResponse(struct soap *soap, int n)
{	return soap_instantiate_tree__getCheckPointDataResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_tree__getCheckPointDataResponse(struct soap *soap, tree__getCheckPointDataResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 tree__getCheckPointDataResponse * SOAP_FMAC6 soap_instantiate_tree__getCheckPointDataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tree__getCheckPointDataResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tree__getCheckPointDataResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new tree__getCheckPointDataResponse;
		if (size)
			*size = sizeof(tree__getCheckPointDataResponse);
	}
	else
	{	cp->ptr = (void*)new tree__getCheckPointDataResponse[n];
		if (size)
			*size = n * sizeof(tree__getCheckPointDataResponse);
	}
	return (tree__getCheckPointDataResponse*)cp->ptr;
}

void tree__addNodeResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_tree__addNodeResponse))
		this->soap_mark(soap);
}

void tree__addNodeResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((tree__addNodeResponse*)this)->_addNodeReturn, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &((tree__addNodeResponse*)this)->_addNodeReturn);
}

void tree__addNodeResponse::soap_default(struct soap *soap)
{
	soap_default_xsd__string(soap, &((tree__addNodeResponse*)this)->_addNodeReturn);
}

int tree__addNodeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_tree__addNodeResponse);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int tree__addNodeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tree__addNodeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tree__addNodeResponse(struct soap *soap, const char *tag, int id, const tree__addNodeResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tree__addNodeResponse), "tree:addNodeResponse");
	soap_out_xsd__string(soap, "addNodeReturn", -1, &(((tree__addNodeResponse*)a)->_addNodeReturn), "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *tree__addNodeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tree__addNodeResponse(soap, this, tag, type);
}

SOAP_FMAC3 tree__addNodeResponse * SOAP_FMAC4 soap_get_tree__addNodeResponse(struct soap *soap, tree__addNodeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tree__addNodeResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *tree__addNodeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tree__addNodeResponse(soap, tag, this, type);
}

SOAP_FMAC3 tree__addNodeResponse * SOAP_FMAC4 soap_in_tree__addNodeResponse(struct soap *soap, const char *tag, tree__addNodeResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (tree__addNodeResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tree__addNodeResponse, sizeof(tree__addNodeResponse), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_tree__addNodeResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (tree__addNodeResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag__addNodeReturn1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag__addNodeReturn1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &(((tree__addNodeResponse*)a)->_addNodeReturn), "xsd:string"))
				{	soap_flag__addNodeReturn1 = 0;
					continue;
				}

			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (tree__addNodeResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tree__addNodeResponse, sizeof(tree__addNodeResponse), soap->type, soap->arrayType), SOAP_TYPE_tree__addNodeResponse, sizeof(tree__addNodeResponse));
		if (soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 tree__addNodeResponse * SOAP_FMAC6 soap_new_tree__addNodeResponse(struct soap *soap, int n)
{	return soap_instantiate_tree__addNodeResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_tree__addNodeResponse(struct soap *soap, tree__addNodeResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 tree__addNodeResponse * SOAP_FMAC6 soap_instantiate_tree__addNodeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tree__addNodeResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tree__addNodeResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new tree__addNodeResponse;
		if (size)
			*size = sizeof(tree__addNodeResponse);
	}
	else
	{	cp->ptr = (void*)new tree__addNodeResponse[n];
		if (size)
			*size = n * sizeof(tree__addNodeResponse);
	}
	return (tree__addNodeResponse*)cp->ptr;
}

void tree__requestTerminationAfterResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_tree__requestTerminationAfterResponse))
		this->soap_mark(soap);
}

void tree__requestTerminationAfterResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((tree__requestTerminationAfterResponse*)this)->_requestTerminationAfterReturn, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &((tree__requestTerminationAfterResponse*)this)->_requestTerminationAfterReturn);
}

void tree__requestTerminationAfterResponse::soap_default(struct soap *soap)
{
	soap_default_xsd__string(soap, &((tree__requestTerminationAfterResponse*)this)->_requestTerminationAfterReturn);
}

int tree__requestTerminationAfterResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_tree__requestTerminationAfterResponse);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int tree__requestTerminationAfterResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tree__requestTerminationAfterResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tree__requestTerminationAfterResponse(struct soap *soap, const char *tag, int id, const tree__requestTerminationAfterResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tree__requestTerminationAfterResponse), "tree:requestTerminationAfterResponse");
	soap_out_xsd__string(soap, "requestTerminationAfterReturn", -1, &(((tree__requestTerminationAfterResponse*)a)->_requestTerminationAfterReturn), "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *tree__requestTerminationAfterResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tree__requestTerminationAfterResponse(soap, this, tag, type);
}

SOAP_FMAC3 tree__requestTerminationAfterResponse * SOAP_FMAC4 soap_get_tree__requestTerminationAfterResponse(struct soap *soap, tree__requestTerminationAfterResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tree__requestTerminationAfterResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *tree__requestTerminationAfterResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tree__requestTerminationAfterResponse(soap, tag, this, type);
}

SOAP_FMAC3 tree__requestTerminationAfterResponse * SOAP_FMAC4 soap_in_tree__requestTerminationAfterResponse(struct soap *soap, const char *tag, tree__requestTerminationAfterResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (tree__requestTerminationAfterResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tree__requestTerminationAfterResponse, sizeof(tree__requestTerminationAfterResponse), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_tree__requestTerminationAfterResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (tree__requestTerminationAfterResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag__requestTerminationAfterReturn1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag__requestTerminationAfterReturn1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &(((tree__requestTerminationAfterResponse*)a)->_requestTerminationAfterReturn), "xsd:string"))
				{	soap_flag__requestTerminationAfterReturn1 = 0;
					continue;
				}

			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (tree__requestTerminationAfterResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tree__requestTerminationAfterResponse, sizeof(tree__requestTerminationAfterResponse), soap->type, soap->arrayType), SOAP_TYPE_tree__requestTerminationAfterResponse, sizeof(tree__requestTerminationAfterResponse));
		if (soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 tree__requestTerminationAfterResponse * SOAP_FMAC6 soap_new_tree__requestTerminationAfterResponse(struct soap *soap, int n)
{	return soap_instantiate_tree__requestTerminationAfterResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_tree__requestTerminationAfterResponse(struct soap *soap, tree__requestTerminationAfterResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 tree__requestTerminationAfterResponse * SOAP_FMAC6 soap_instantiate_tree__requestTerminationAfterResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tree__requestTerminationAfterResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tree__requestTerminationAfterResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new tree__requestTerminationAfterResponse;
		if (size)
			*size = sizeof(tree__requestTerminationAfterResponse);
	}
	else
	{	cp->ptr = (void*)new tree__requestTerminationAfterResponse[n];
		if (size)
			*size = n * sizeof(tree__requestTerminationAfterResponse);
	}
	return (tree__requestTerminationAfterResponse*)cp->ptr;
}

void tree__getParentNodeResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_tree__getParentNodeResponse))
		this->soap_mark(soap);
}

void tree__getParentNodeResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((tree__getParentNodeResponse*)this)->_getParentNodeReturn, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &((tree__getParentNodeResponse*)this)->_getParentNodeReturn);
}

void tree__getParentNodeResponse::soap_default(struct soap *soap)
{
	soap_default_xsd__string(soap, &((tree__getParentNodeResponse*)this)->_getParentNodeReturn);
}

int tree__getParentNodeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_tree__getParentNodeResponse);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int tree__getParentNodeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tree__getParentNodeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tree__getParentNodeResponse(struct soap *soap, const char *tag, int id, const tree__getParentNodeResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tree__getParentNodeResponse), "tree:getParentNodeResponse");
	soap_out_xsd__string(soap, "getParentNodeReturn", -1, &(((tree__getParentNodeResponse*)a)->_getParentNodeReturn), "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *tree__getParentNodeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tree__getParentNodeResponse(soap, this, tag, type);
}

SOAP_FMAC3 tree__getParentNodeResponse * SOAP_FMAC4 soap_get_tree__getParentNodeResponse(struct soap *soap, tree__getParentNodeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tree__getParentNodeResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *tree__getParentNodeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tree__getParentNodeResponse(soap, tag, this, type);
}

SOAP_FMAC3 tree__getParentNodeResponse * SOAP_FMAC4 soap_in_tree__getParentNodeResponse(struct soap *soap, const char *tag, tree__getParentNodeResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (tree__getParentNodeResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tree__getParentNodeResponse, sizeof(tree__getParentNodeResponse), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_tree__getParentNodeResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (tree__getParentNodeResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag__getParentNodeReturn1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag__getParentNodeReturn1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &(((tree__getParentNodeResponse*)a)->_getParentNodeReturn), "xsd:string"))
				{	soap_flag__getParentNodeReturn1 = 0;
					continue;
				}

			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (tree__getParentNodeResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tree__getParentNodeResponse, sizeof(tree__getParentNodeResponse), soap->type, soap->arrayType), SOAP_TYPE_tree__getParentNodeResponse, sizeof(tree__getParentNodeResponse));
		if (soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 tree__getParentNodeResponse * SOAP_FMAC6 soap_new_tree__getParentNodeResponse(struct soap *soap, int n)
{	return soap_instantiate_tree__getParentNodeResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_tree__getParentNodeResponse(struct soap *soap, tree__getParentNodeResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 tree__getParentNodeResponse * SOAP_FMAC6 soap_instantiate_tree__getParentNodeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tree__getParentNodeResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tree__getParentNodeResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new tree__getParentNodeResponse;
		if (size)
			*size = sizeof(tree__getParentNodeResponse);
	}
	else
	{	cp->ptr = (void*)new tree__getParentNodeResponse[n];
		if (size)
			*size = n * sizeof(tree__getParentNodeResponse);
	}
	return (tree__getParentNodeResponse*)cp->ptr;
}

void fact__destroyResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_fact__destroyResponse))
		this->soap_mark(soap);
}

void fact__destroyResponse::soap_mark(struct soap *soap) const
{
}

void fact__destroyResponse::soap_default(struct soap *soap)
{
}

int fact__destroyResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_fact__destroyResponse);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int fact__destroyResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fact__destroyResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fact__destroyResponse(struct soap *soap, const char *tag, int id, const fact__destroyResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fact__destroyResponse), "fact:destroyResponse");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *fact__destroyResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fact__destroyResponse(soap, this, tag, type);
}

SOAP_FMAC3 fact__destroyResponse * SOAP_FMAC4 soap_get_fact__destroyResponse(struct soap *soap, fact__destroyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_fact__destroyResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *fact__destroyResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fact__destroyResponse(soap, tag, this, type);
}

SOAP_FMAC3 fact__destroyResponse * SOAP_FMAC4 soap_in_fact__destroyResponse(struct soap *soap, const char *tag, fact__destroyResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (fact__destroyResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fact__destroyResponse, sizeof(fact__destroyResponse), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_fact__destroyResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (fact__destroyResponse *)a->soap_in(soap, tag, type);
			}
		};
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (fact__destroyResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fact__destroyResponse, sizeof(fact__destroyResponse), soap->type, soap->arrayType), SOAP_TYPE_fact__destroyResponse, sizeof(fact__destroyResponse));
		if (soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 fact__destroyResponse * SOAP_FMAC6 soap_new_fact__destroyResponse(struct soap *soap, int n)
{	return soap_instantiate_fact__destroyResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_fact__destroyResponse(struct soap *soap, fact__destroyResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 fact__destroyResponse * SOAP_FMAC6 soap_instantiate_fact__destroyResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fact__destroyResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fact__destroyResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new fact__destroyResponse;
		if (size)
			*size = sizeof(fact__destroyResponse);
	}
	else
	{	cp->ptr = (void*)new fact__destroyResponse[n];
		if (size)
			*size = n * sizeof(fact__destroyResponse);
	}
	return (fact__destroyResponse*)cp->ptr;
}

void fact__requestTerminationAfterResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_fact__requestTerminationAfterResponse))
		this->soap_mark(soap);
}

void fact__requestTerminationAfterResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((fact__requestTerminationAfterResponse*)this)->_requestTerminationAfterReturn, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &((fact__requestTerminationAfterResponse*)this)->_requestTerminationAfterReturn);
}

void fact__requestTerminationAfterResponse::soap_default(struct soap *soap)
{
	soap_default_xsd__string(soap, &((fact__requestTerminationAfterResponse*)this)->_requestTerminationAfterReturn);
}

int fact__requestTerminationAfterResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_fact__requestTerminationAfterResponse);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int fact__requestTerminationAfterResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fact__requestTerminationAfterResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fact__requestTerminationAfterResponse(struct soap *soap, const char *tag, int id, const fact__requestTerminationAfterResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fact__requestTerminationAfterResponse), "fact:requestTerminationAfterResponse");
	soap_out_xsd__string(soap, "requestTerminationAfterReturn", -1, &(((fact__requestTerminationAfterResponse*)a)->_requestTerminationAfterReturn), "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *fact__requestTerminationAfterResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fact__requestTerminationAfterResponse(soap, this, tag, type);
}

SOAP_FMAC3 fact__requestTerminationAfterResponse * SOAP_FMAC4 soap_get_fact__requestTerminationAfterResponse(struct soap *soap, fact__requestTerminationAfterResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_fact__requestTerminationAfterResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *fact__requestTerminationAfterResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fact__requestTerminationAfterResponse(soap, tag, this, type);
}

SOAP_FMAC3 fact__requestTerminationAfterResponse * SOAP_FMAC4 soap_in_fact__requestTerminationAfterResponse(struct soap *soap, const char *tag, fact__requestTerminationAfterResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (fact__requestTerminationAfterResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fact__requestTerminationAfterResponse, sizeof(fact__requestTerminationAfterResponse), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_fact__requestTerminationAfterResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (fact__requestTerminationAfterResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag__requestTerminationAfterReturn1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag__requestTerminationAfterReturn1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &(((fact__requestTerminationAfterResponse*)a)->_requestTerminationAfterReturn), "xsd:string"))
				{	soap_flag__requestTerminationAfterReturn1 = 0;
					continue;
				}

			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (fact__requestTerminationAfterResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fact__requestTerminationAfterResponse, sizeof(fact__requestTerminationAfterResponse), soap->type, soap->arrayType), SOAP_TYPE_fact__requestTerminationAfterResponse, sizeof(fact__requestTerminationAfterResponse));
		if (soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 fact__requestTerminationAfterResponse * SOAP_FMAC6 soap_new_fact__requestTerminationAfterResponse(struct soap *soap, int n)
{	return soap_instantiate_fact__requestTerminationAfterResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_fact__requestTerminationAfterResponse(struct soap *soap, fact__requestTerminationAfterResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 fact__requestTerminationAfterResponse * SOAP_FMAC6 soap_instantiate_fact__requestTerminationAfterResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fact__requestTerminationAfterResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fact__requestTerminationAfterResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new fact__requestTerminationAfterResponse;
		if (size)
			*size = sizeof(fact__requestTerminationAfterResponse);
	}
	else
	{	cp->ptr = (void*)new fact__requestTerminationAfterResponse[n];
		if (size)
			*size = n * sizeof(fact__requestTerminationAfterResponse);
	}
	return (fact__requestTerminationAfterResponse*)cp->ptr;
}

void fact__createNewTreeResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_fact__createNewTreeResponse))
		this->soap_mark(soap);
}

void fact__createNewTreeResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((fact__createNewTreeResponse*)this)->_createNewTreeReturn, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &((fact__createNewTreeResponse*)this)->_createNewTreeReturn);
}

void fact__createNewTreeResponse::soap_default(struct soap *soap)
{
	soap_default_xsd__string(soap, &((fact__createNewTreeResponse*)this)->_createNewTreeReturn);
}

int fact__createNewTreeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_fact__createNewTreeResponse);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int fact__createNewTreeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fact__createNewTreeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fact__createNewTreeResponse(struct soap *soap, const char *tag, int id, const fact__createNewTreeResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fact__createNewTreeResponse), "fact:createNewTreeResponse");
	soap_out_xsd__string(soap, "createNewTreeReturn", -1, &(((fact__createNewTreeResponse*)a)->_createNewTreeReturn), "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *fact__createNewTreeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fact__createNewTreeResponse(soap, this, tag, type);
}

SOAP_FMAC3 fact__createNewTreeResponse * SOAP_FMAC4 soap_get_fact__createNewTreeResponse(struct soap *soap, fact__createNewTreeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_fact__createNewTreeResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *fact__createNewTreeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fact__createNewTreeResponse(soap, tag, this, type);
}

SOAP_FMAC3 fact__createNewTreeResponse * SOAP_FMAC4 soap_in_fact__createNewTreeResponse(struct soap *soap, const char *tag, fact__createNewTreeResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (fact__createNewTreeResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fact__createNewTreeResponse, sizeof(fact__createNewTreeResponse), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_fact__createNewTreeResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (fact__createNewTreeResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag__createNewTreeReturn1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag__createNewTreeReturn1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &(((fact__createNewTreeResponse*)a)->_createNewTreeReturn), "xsd:string"))
				{	soap_flag__createNewTreeReturn1 = 0;
					continue;
				}

			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (fact__createNewTreeResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fact__createNewTreeResponse, sizeof(fact__createNewTreeResponse), soap->type, soap->arrayType), SOAP_TYPE_fact__createNewTreeResponse, sizeof(fact__createNewTreeResponse));
		if (soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 fact__createNewTreeResponse * SOAP_FMAC6 soap_new_fact__createNewTreeResponse(struct soap *soap, int n)
{	return soap_instantiate_fact__createNewTreeResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_fact__createNewTreeResponse(struct soap *soap, fact__createNewTreeResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 fact__createNewTreeResponse * SOAP_FMAC6 soap_instantiate_fact__createNewTreeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fact__createNewTreeResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fact__createNewTreeResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new fact__createNewTreeResponse;
		if (size)
			*size = sizeof(fact__createNewTreeResponse);
	}
	else
	{	cp->ptr = (void*)new fact__createNewTreeResponse[n];
		if (size)
			*size = n * sizeof(fact__createNewTreeResponse);
	}
	return (fact__createNewTreeResponse*)cp->ptr;
}

void fact__getActiveTreesResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_fact__getActiveTreesResponse))
		this->soap_mark(soap);
}

void fact__getActiveTreesResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((fact__getActiveTreesResponse*)this)->_getActiveTreesReturn, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &((fact__getActiveTreesResponse*)this)->_getActiveTreesReturn);
}

void fact__getActiveTreesResponse::soap_default(struct soap *soap)
{
	soap_default_xsd__string(soap, &((fact__getActiveTreesResponse*)this)->_getActiveTreesReturn);
}

int fact__getActiveTreesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_fact__getActiveTreesResponse);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int fact__getActiveTreesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fact__getActiveTreesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fact__getActiveTreesResponse(struct soap *soap, const char *tag, int id, const fact__getActiveTreesResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fact__getActiveTreesResponse), "fact:getActiveTreesResponse");
	soap_out_xsd__string(soap, "getActiveTreesReturn", -1, &(((fact__getActiveTreesResponse*)a)->_getActiveTreesReturn), "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *fact__getActiveTreesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fact__getActiveTreesResponse(soap, this, tag, type);
}

SOAP_FMAC3 fact__getActiveTreesResponse * SOAP_FMAC4 soap_get_fact__getActiveTreesResponse(struct soap *soap, fact__getActiveTreesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_fact__getActiveTreesResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *fact__getActiveTreesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fact__getActiveTreesResponse(soap, tag, this, type);
}

SOAP_FMAC3 fact__getActiveTreesResponse * SOAP_FMAC4 soap_in_fact__getActiveTreesResponse(struct soap *soap, const char *tag, fact__getActiveTreesResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (fact__getActiveTreesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fact__getActiveTreesResponse, sizeof(fact__getActiveTreesResponse), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_fact__getActiveTreesResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (fact__getActiveTreesResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag__getActiveTreesReturn1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag__getActiveTreesReturn1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &(((fact__getActiveTreesResponse*)a)->_getActiveTreesReturn), "xsd:string"))
				{	soap_flag__getActiveTreesReturn1 = 0;
					continue;
				}

			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (fact__getActiveTreesResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fact__getActiveTreesResponse, sizeof(fact__getActiveTreesResponse), soap->type, soap->arrayType), SOAP_TYPE_fact__getActiveTreesResponse, sizeof(fact__getActiveTreesResponse));
		if (soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 fact__getActiveTreesResponse * SOAP_FMAC6 soap_new_fact__getActiveTreesResponse(struct soap *soap, int n)
{	return soap_instantiate_fact__getActiveTreesResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_fact__getActiveTreesResponse(struct soap *soap, fact__getActiveTreesResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 fact__getActiveTreesResponse * SOAP_FMAC6 soap_instantiate_fact__getActiveTreesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fact__getActiveTreesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fact__getActiveTreesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new fact__getActiveTreesResponse;
		if (size)
			*size = sizeof(fact__getActiveTreesResponse);
	}
	else
	{	cp->ptr = (void*)new fact__getActiveTreesResponse[n];
		if (size)
			*size = n * sizeof(fact__getActiveTreesResponse);
	}
	return (fact__getActiveTreesResponse*)cp->ptr;
}

void fact__findByHandleResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_fact__findByHandleResponse))
		this->soap_mark(soap);
}

void fact__findByHandleResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((fact__findByHandleResponse*)this)->_findByHandleReturn, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &((fact__findByHandleResponse*)this)->_findByHandleReturn);
}

void fact__findByHandleResponse::soap_default(struct soap *soap)
{
	soap_default_xsd__string(soap, &((fact__findByHandleResponse*)this)->_findByHandleReturn);
}

int fact__findByHandleResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_fact__findByHandleResponse);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int fact__findByHandleResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fact__findByHandleResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fact__findByHandleResponse(struct soap *soap, const char *tag, int id, const fact__findByHandleResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fact__findByHandleResponse), "fact:findByHandleResponse");
	soap_out_xsd__string(soap, "findByHandleReturn", -1, &(((fact__findByHandleResponse*)a)->_findByHandleReturn), "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *fact__findByHandleResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fact__findByHandleResponse(soap, this, tag, type);
}

SOAP_FMAC3 fact__findByHandleResponse * SOAP_FMAC4 soap_get_fact__findByHandleResponse(struct soap *soap, fact__findByHandleResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_fact__findByHandleResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *fact__findByHandleResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fact__findByHandleResponse(soap, tag, this, type);
}

SOAP_FMAC3 fact__findByHandleResponse * SOAP_FMAC4 soap_in_fact__findByHandleResponse(struct soap *soap, const char *tag, fact__findByHandleResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (fact__findByHandleResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fact__findByHandleResponse, sizeof(fact__findByHandleResponse), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_fact__findByHandleResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (fact__findByHandleResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag__findByHandleReturn1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag__findByHandleReturn1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &(((fact__findByHandleResponse*)a)->_findByHandleReturn), "xsd:string"))
				{	soap_flag__findByHandleReturn1 = 0;
					continue;
				}

			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (fact__findByHandleResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fact__findByHandleResponse, sizeof(fact__findByHandleResponse), soap->type, soap->arrayType), SOAP_TYPE_fact__findByHandleResponse, sizeof(fact__findByHandleResponse));
		if (soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 fact__findByHandleResponse * SOAP_FMAC6 soap_new_fact__findByHandleResponse(struct soap *soap, int n)
{	return soap_instantiate_fact__findByHandleResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_fact__findByHandleResponse(struct soap *soap, fact__findByHandleResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 fact__findByHandleResponse * SOAP_FMAC6 soap_instantiate_fact__findByHandleResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fact__findByHandleResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fact__findByHandleResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new fact__findByHandleResponse;
		if (size)
			*size = sizeof(fact__findByHandleResponse);
	}
	else
	{	cp->ptr = (void*)new fact__findByHandleResponse[n];
		if (size)
			*size = n * sizeof(fact__findByHandleResponse);
	}
	return (fact__findByHandleResponse*)cp->ptr;
}

void fact__findServiceDataResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_fact__findServiceDataResponse))
		this->soap_mark(soap);
}

void fact__findServiceDataResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((fact__findServiceDataResponse*)this)->_findServiceDataReturn, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &((fact__findServiceDataResponse*)this)->_findServiceDataReturn);
}

void fact__findServiceDataResponse::soap_default(struct soap *soap)
{
	soap_default_xsd__string(soap, &((fact__findServiceDataResponse*)this)->_findServiceDataReturn);
}

int fact__findServiceDataResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_fact__findServiceDataResponse);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int fact__findServiceDataResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fact__findServiceDataResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fact__findServiceDataResponse(struct soap *soap, const char *tag, int id, const fact__findServiceDataResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fact__findServiceDataResponse), "fact:findServiceDataResponse");
	soap_out_xsd__string(soap, "findServiceDataReturn", -1, &(((fact__findServiceDataResponse*)a)->_findServiceDataReturn), "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *fact__findServiceDataResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fact__findServiceDataResponse(soap, this, tag, type);
}

SOAP_FMAC3 fact__findServiceDataResponse * SOAP_FMAC4 soap_get_fact__findServiceDataResponse(struct soap *soap, fact__findServiceDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_fact__findServiceDataResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *fact__findServiceDataResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fact__findServiceDataResponse(soap, tag, this, type);
}

SOAP_FMAC3 fact__findServiceDataResponse * SOAP_FMAC4 soap_in_fact__findServiceDataResponse(struct soap *soap, const char *tag, fact__findServiceDataResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (fact__findServiceDataResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fact__findServiceDataResponse, sizeof(fact__findServiceDataResponse), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_fact__findServiceDataResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (fact__findServiceDataResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag__findServiceDataReturn1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag__findServiceDataReturn1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &(((fact__findServiceDataResponse*)a)->_findServiceDataReturn), "xsd:string"))
				{	soap_flag__findServiceDataReturn1 = 0;
					continue;
				}

			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (fact__findServiceDataResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fact__findServiceDataResponse, sizeof(fact__findServiceDataResponse), soap->type, soap->arrayType), SOAP_TYPE_fact__findServiceDataResponse, sizeof(fact__findServiceDataResponse));
		if (soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 fact__findServiceDataResponse * SOAP_FMAC6 soap_new_fact__findServiceDataResponse(struct soap *soap, int n)
{	return soap_instantiate_fact__findServiceDataResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_fact__findServiceDataResponse(struct soap *soap, fact__findServiceDataResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 fact__findServiceDataResponse * SOAP_FMAC6 soap_instantiate_fact__findServiceDataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fact__findServiceDataResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fact__findServiceDataResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new fact__findServiceDataResponse;
		if (size)
			*size = sizeof(fact__findServiceDataResponse);
	}
	else
	{	cp->ptr = (void*)new fact__findServiceDataResponse[n];
		if (size)
			*size = n * sizeof(fact__findServiceDataResponse);
	}
	return (fact__findServiceDataResponse*)cp->ptr;
}

void fact__requestTerminationBeforeResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_fact__requestTerminationBeforeResponse))
		this->soap_mark(soap);
}

void fact__requestTerminationBeforeResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((fact__requestTerminationBeforeResponse*)this)->_requestTerminationBeforeReturn, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &((fact__requestTerminationBeforeResponse*)this)->_requestTerminationBeforeReturn);
}

void fact__requestTerminationBeforeResponse::soap_default(struct soap *soap)
{
	soap_default_xsd__string(soap, &((fact__requestTerminationBeforeResponse*)this)->_requestTerminationBeforeReturn);
}

int fact__requestTerminationBeforeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i = soap_embed_element(soap, (void*)this, tag, SOAP_TYPE_fact__requestTerminationBeforeResponse);
	this->soap_out(soap, tag, i, type);
	return soap_putindependent(soap);
}

int fact__requestTerminationBeforeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_fact__requestTerminationBeforeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fact__requestTerminationBeforeResponse(struct soap *soap, const char *tag, int id, const fact__requestTerminationBeforeResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fact__requestTerminationBeforeResponse), "fact:requestTerminationBeforeResponse");
	soap_out_xsd__string(soap, "requestTerminationBeforeReturn", -1, &(((fact__requestTerminationBeforeResponse*)a)->_requestTerminationBeforeReturn), "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *fact__requestTerminationBeforeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_fact__requestTerminationBeforeResponse(soap, this, tag, type);
}

SOAP_FMAC3 fact__requestTerminationBeforeResponse * SOAP_FMAC4 soap_get_fact__requestTerminationBeforeResponse(struct soap *soap, fact__requestTerminationBeforeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_fact__requestTerminationBeforeResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *fact__requestTerminationBeforeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_fact__requestTerminationBeforeResponse(soap, tag, this, type);
}

SOAP_FMAC3 fact__requestTerminationBeforeResponse * SOAP_FMAC4 soap_in_fact__requestTerminationBeforeResponse(struct soap *soap, const char *tag, fact__requestTerminationBeforeResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (fact__requestTerminationBeforeResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fact__requestTerminationBeforeResponse, sizeof(fact__requestTerminationBeforeResponse), soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_fact__requestTerminationBeforeResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (fact__requestTerminationBeforeResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag__requestTerminationBeforeReturn1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag__requestTerminationBeforeReturn1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, NULL, &(((fact__requestTerminationBeforeResponse*)a)->_requestTerminationBeforeReturn), "xsd:string"))
				{	soap_flag__requestTerminationBeforeReturn1 = 0;
					continue;
				}

			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (fact__requestTerminationBeforeResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_fact__requestTerminationBeforeResponse, sizeof(fact__requestTerminationBeforeResponse), soap->type, soap->arrayType), SOAP_TYPE_fact__requestTerminationBeforeResponse, sizeof(fact__requestTerminationBeforeResponse));
		if (soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 fact__requestTerminationBeforeResponse * SOAP_FMAC6 soap_new_fact__requestTerminationBeforeResponse(struct soap *soap, int n)
{	return soap_instantiate_fact__requestTerminationBeforeResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_fact__requestTerminationBeforeResponse(struct soap *soap, fact__requestTerminationBeforeResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC5 fact__requestTerminationBeforeResponse * SOAP_FMAC6 soap_instantiate_fact__requestTerminationBeforeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_fact__requestTerminationBeforeResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_fact__requestTerminationBeforeResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	soap->alloced = 1;
	if (n < 0)
	{	cp->ptr = (void*)new fact__requestTerminationBeforeResponse;
		if (size)
			*size = sizeof(fact__requestTerminationBeforeResponse);
	}
	else
	{	cp->ptr = (void*)new fact__requestTerminationBeforeResponse[n];
		if (size)
			*size = n * sizeof(fact__requestTerminationBeforeResponse);
	}
	return (fact__requestTerminationBeforeResponse*)cp->ptr;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_SOAP_ENV__Fault))
		soap_mark_SOAP_ENV__Fault(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	soap_embedded(soap, &a->faultcode, SOAP_TYPE__QName);
	soap_mark__QName(soap, &a->faultcode);
	soap_embedded(soap, &a->faultstring, SOAP_TYPE_string);
	soap_mark_string(soap, &a->faultstring);
	soap_embedded(soap, &a->faultactor, SOAP_TYPE_string);
	soap_mark_string(soap, &a->faultactor);
	soap_embedded(soap, &a->detail, SOAP_TYPE_string);
	soap_mark_string(soap, &a->detail);
	soap_embedded(soap, &a->SOAP_ENV__Code, SOAP_TYPE_PointerToSOAP_ENV__Code);
	soap_mark_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_embedded(soap, &a->SOAP_ENV__Reason, SOAP_TYPE_string);
	soap_mark_string(soap, &a->SOAP_ENV__Reason);
	soap_embedded(soap, &a->SOAP_ENV__Detail, SOAP_TYPE_string);
	soap_mark_string(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	soap_default_string(soap, &a->detail);
	soap_default_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_default_string(soap, &a->SOAP_ENV__Reason);
	soap_default_string(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_SOAP_ENV__Fault);
	soap_out_SOAP_ENV__Fault(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type);
	soap_out__QName(soap, "faultcode", -1, &a->faultcode, "");
	soap_out_string(soap, "faultstring", -1, &a->faultstring, "");
	soap_out_string(soap, "faultactor", -1, &a->faultactor, "");
	soap_out_string(soap, "detail", -1, &a->detail, "");
	soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, "");
	soap_out_string(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, "");
	soap_out_string(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	short soap_flag_faultcode = 1, soap_flag_faultstring = 1, soap_flag_faultactor = 1, soap_flag_detail = 1, soap_flag_SOAP_ENV__Code = 1, soap_flag_SOAP_ENV__Reason = 1, soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_SOAP_ENV__Fault(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode = 0;
					continue;
				}
			if (soap_flag_faultstring && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "faultstring", &a->faultstring, ""))
				{	soap_flag_faultstring = 0;
					continue;
				}
			if (soap_flag_faultactor && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "faultactor", &a->faultactor, ""))
				{	soap_flag_faultactor = 0;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "detail", &a->detail, ""))
				{	soap_flag_detail = 0;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code = 0;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason = 0;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0), SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault));
		if (soap->alloced)
			soap_default_SOAP_ENV__Fault(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_SOAP_ENV__Code))
		soap_mark_SOAP_ENV__Code(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	soap_embedded(soap, &a->SOAP_ENV__Value, SOAP_TYPE__QName);
	soap_mark__QName(soap, &a->SOAP_ENV__Value);
	soap_embedded(soap, &a->SOAP_ENV__Node, SOAP_TYPE_string);
	soap_mark_string(soap, &a->SOAP_ENV__Node);
	soap_embedded(soap, &a->SOAP_ENV__Role, SOAP_TYPE_string);
	soap_mark_string(soap, &a->SOAP_ENV__Role);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_SOAP_ENV__Code);
	soap_out_SOAP_ENV__Code(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type);
	soap_out__QName(soap, "SOAP-ENV:Value", -1, &a->SOAP_ENV__Value, "");
	soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, "");
	soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	short soap_flag_SOAP_ENV__Value = 1, soap_flag_SOAP_ENV__Node = 1, soap_flag_SOAP_ENV__Role = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_SOAP_ENV__Code(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value = 0;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, ""))
				{	soap_flag_SOAP_ENV__Node = 0;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, ""))
				{	soap_flag_SOAP_ENV__Role = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0), SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code));
		if (soap->alloced)
			soap_default_SOAP_ENV__Code(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_SOAP_ENV__Header))
		soap_mark_SOAP_ENV__Header(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	/* transient dummy skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	/* transient dummy skipped */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_SOAP_ENV__Header);
	soap_out_SOAP_ENV__Header(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type);
	/* transient dummy skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_SOAP_ENV__Header(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
		/* transient dummy skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0), SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header));
		if (soap->alloced)
			soap_default_SOAP_ENV__Header(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tree__addNode(struct soap *soap, struct tree__addNode const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_tree__addNode))
		soap_mark_tree__addNode(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_tree__addNode(struct soap *soap, const struct tree__addNode *a)
{
	soap_embedded(soap, &a->in0, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->in0);
	soap_embedded(soap, &a->in1, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->in1);
	soap_embedded(soap, &a->in2, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->in2);
	soap_embedded(soap, &a->in3, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->in3);
	soap_embedded(soap, &a->in4, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->in4);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tree__addNode(struct soap *soap, struct tree__addNode *a)
{
	soap_default_xsd__string(soap, &a->in0);
	soap_default_xsd__string(soap, &a->in1);
	soap_default_xsd__string(soap, &a->in2);
	soap_default_xsd__string(soap, &a->in3);
	soap_default_xsd__string(soap, &a->in4);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tree__addNode(struct soap *soap, struct tree__addNode *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_tree__addNode);
	soap_out_tree__addNode(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tree__addNode(struct soap *soap, const char *tag, int id, const struct tree__addNode *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tree__addNode), type);
	soap_out_xsd__string(soap, "in0", -1, &a->in0, "xsd:string");
	soap_out_xsd__string(soap, "in1", -1, &a->in1, "xsd:string");
	soap_out_xsd__string(soap, "in2", -1, &a->in2, "xsd:string");
	soap_out_xsd__string(soap, "in3", -1, &a->in3, "xsd:string");
	soap_out_xsd__string(soap, "in4", -1, &a->in4, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct tree__addNode * SOAP_FMAC4 soap_get_tree__addNode(struct soap *soap, struct tree__addNode *p, const char *tag, const char *type)
{
	if ((p = soap_in_tree__addNode(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct tree__addNode * SOAP_FMAC4 soap_in_tree__addNode(struct soap *soap, const char *tag, struct tree__addNode *a, const char *type)
{
	short soap_flag_in0 = 1, soap_flag_in1 = 1, soap_flag_in2 = 1, soap_flag_in3 = 1, soap_flag_in4 = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct tree__addNode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tree__addNode, sizeof(struct tree__addNode), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tree__addNode(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in0 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "in0", &a->in0, "xsd:string"))
				{	soap_flag_in0 = 0;
					continue;
				}
			if (soap_flag_in1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "in1", &a->in1, "xsd:string"))
				{	soap_flag_in1 = 0;
					continue;
				}
			if (soap_flag_in2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "in2", &a->in2, "xsd:string"))
				{	soap_flag_in2 = 0;
					continue;
				}
			if (soap_flag_in3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "in3", &a->in3, "xsd:string"))
				{	soap_flag_in3 = 0;
					continue;
				}
			if (soap_flag_in4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "in4", &a->in4, "xsd:string"))
				{	soap_flag_in4 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct tree__addNode *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tree__addNode, sizeof(struct tree__addNode), 0), SOAP_TYPE_tree__addNode, sizeof(struct tree__addNode));
		if (soap->alloced)
			soap_default_tree__addNode(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tree__getParentNode(struct soap *soap, struct tree__getParentNode const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_tree__getParentNode))
		soap_mark_tree__getParentNode(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_tree__getParentNode(struct soap *soap, const struct tree__getParentNode *a)
{
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tree__getParentNode(struct soap *soap, struct tree__getParentNode *a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tree__getParentNode(struct soap *soap, struct tree__getParentNode *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_tree__getParentNode);
	soap_out_tree__getParentNode(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tree__getParentNode(struct soap *soap, const char *tag, int id, const struct tree__getParentNode *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tree__getParentNode), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct tree__getParentNode * SOAP_FMAC4 soap_get_tree__getParentNode(struct soap *soap, struct tree__getParentNode *p, const char *tag, const char *type)
{
	if ((p = soap_in_tree__getParentNode(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct tree__getParentNode * SOAP_FMAC4 soap_in_tree__getParentNode(struct soap *soap, const char *tag, struct tree__getParentNode *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct tree__getParentNode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tree__getParentNode, sizeof(struct tree__getParentNode), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tree__getParentNode(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct tree__getParentNode *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tree__getParentNode, sizeof(struct tree__getParentNode), 0), SOAP_TYPE_tree__getParentNode, sizeof(struct tree__getParentNode));
		if (soap->alloced)
			soap_default_tree__getParentNode(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tree__getCheckPointData(struct soap *soap, struct tree__getCheckPointData const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_tree__getCheckPointData))
		soap_mark_tree__getCheckPointData(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_tree__getCheckPointData(struct soap *soap, const struct tree__getCheckPointData *a)
{
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tree__getCheckPointData(struct soap *soap, struct tree__getCheckPointData *a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tree__getCheckPointData(struct soap *soap, struct tree__getCheckPointData *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_tree__getCheckPointData);
	soap_out_tree__getCheckPointData(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tree__getCheckPointData(struct soap *soap, const char *tag, int id, const struct tree__getCheckPointData *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tree__getCheckPointData), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct tree__getCheckPointData * SOAP_FMAC4 soap_get_tree__getCheckPointData(struct soap *soap, struct tree__getCheckPointData *p, const char *tag, const char *type)
{
	if ((p = soap_in_tree__getCheckPointData(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct tree__getCheckPointData * SOAP_FMAC4 soap_in_tree__getCheckPointData(struct soap *soap, const char *tag, struct tree__getCheckPointData *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct tree__getCheckPointData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tree__getCheckPointData, sizeof(struct tree__getCheckPointData), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tree__getCheckPointData(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct tree__getCheckPointData *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tree__getCheckPointData, sizeof(struct tree__getCheckPointData), 0), SOAP_TYPE_tree__getCheckPointData, sizeof(struct tree__getCheckPointData));
		if (soap->alloced)
			soap_default_tree__getCheckPointData(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tree__requestTerminationBefore(struct soap *soap, struct tree__requestTerminationBefore const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_tree__requestTerminationBefore))
		soap_mark_tree__requestTerminationBefore(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_tree__requestTerminationBefore(struct soap *soap, const struct tree__requestTerminationBefore *a)
{
	soap_embedded(soap, &a->in0, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tree__requestTerminationBefore(struct soap *soap, struct tree__requestTerminationBefore *a)
{
	soap_default_xsd__string(soap, &a->in0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tree__requestTerminationBefore(struct soap *soap, struct tree__requestTerminationBefore *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_tree__requestTerminationBefore);
	soap_out_tree__requestTerminationBefore(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tree__requestTerminationBefore(struct soap *soap, const char *tag, int id, const struct tree__requestTerminationBefore *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tree__requestTerminationBefore), type);
	soap_out_xsd__string(soap, "in0", -1, &a->in0, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct tree__requestTerminationBefore * SOAP_FMAC4 soap_get_tree__requestTerminationBefore(struct soap *soap, struct tree__requestTerminationBefore *p, const char *tag, const char *type)
{
	if ((p = soap_in_tree__requestTerminationBefore(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct tree__requestTerminationBefore * SOAP_FMAC4 soap_in_tree__requestTerminationBefore(struct soap *soap, const char *tag, struct tree__requestTerminationBefore *a, const char *type)
{
	short soap_flag_in0 = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct tree__requestTerminationBefore *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tree__requestTerminationBefore, sizeof(struct tree__requestTerminationBefore), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tree__requestTerminationBefore(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in0 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "in0", &a->in0, "xsd:string"))
				{	soap_flag_in0 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct tree__requestTerminationBefore *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tree__requestTerminationBefore, sizeof(struct tree__requestTerminationBefore), 0), SOAP_TYPE_tree__requestTerminationBefore, sizeof(struct tree__requestTerminationBefore));
		if (soap->alloced)
			soap_default_tree__requestTerminationBefore(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tree__getSteeringCommands(struct soap *soap, struct tree__getSteeringCommands const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_tree__getSteeringCommands))
		soap_mark_tree__getSteeringCommands(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_tree__getSteeringCommands(struct soap *soap, const struct tree__getSteeringCommands *a)
{
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tree__getSteeringCommands(struct soap *soap, struct tree__getSteeringCommands *a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tree__getSteeringCommands(struct soap *soap, struct tree__getSteeringCommands *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_tree__getSteeringCommands);
	soap_out_tree__getSteeringCommands(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tree__getSteeringCommands(struct soap *soap, const char *tag, int id, const struct tree__getSteeringCommands *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tree__getSteeringCommands), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct tree__getSteeringCommands * SOAP_FMAC4 soap_get_tree__getSteeringCommands(struct soap *soap, struct tree__getSteeringCommands *p, const char *tag, const char *type)
{
	if ((p = soap_in_tree__getSteeringCommands(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct tree__getSteeringCommands * SOAP_FMAC4 soap_in_tree__getSteeringCommands(struct soap *soap, const char *tag, struct tree__getSteeringCommands *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct tree__getSteeringCommands *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tree__getSteeringCommands, sizeof(struct tree__getSteeringCommands), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tree__getSteeringCommands(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct tree__getSteeringCommands *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tree__getSteeringCommands, sizeof(struct tree__getSteeringCommands), 0), SOAP_TYPE_tree__getSteeringCommands, sizeof(struct tree__getSteeringCommands));
		if (soap->alloced)
			soap_default_tree__getSteeringCommands(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tree__destroy(struct soap *soap, struct tree__destroy const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_tree__destroy))
		soap_mark_tree__destroy(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_tree__destroy(struct soap *soap, const struct tree__destroy *a)
{
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tree__destroy(struct soap *soap, struct tree__destroy *a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tree__destroy(struct soap *soap, struct tree__destroy *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_tree__destroy);
	soap_out_tree__destroy(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tree__destroy(struct soap *soap, const char *tag, int id, const struct tree__destroy *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tree__destroy), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct tree__destroy * SOAP_FMAC4 soap_get_tree__destroy(struct soap *soap, struct tree__destroy *p, const char *tag, const char *type)
{
	if ((p = soap_in_tree__destroy(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct tree__destroy * SOAP_FMAC4 soap_in_tree__destroy(struct soap *soap, const char *tag, struct tree__destroy *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct tree__destroy *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tree__destroy, sizeof(struct tree__destroy), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tree__destroy(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct tree__destroy *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tree__destroy, sizeof(struct tree__destroy), 0), SOAP_TYPE_tree__destroy, sizeof(struct tree__destroy));
		if (soap->alloced)
			soap_default_tree__destroy(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tree__setCheckPointData(struct soap *soap, struct tree__setCheckPointData const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_tree__setCheckPointData))
		soap_mark_tree__setCheckPointData(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_tree__setCheckPointData(struct soap *soap, const struct tree__setCheckPointData *a)
{
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tree__setCheckPointData(struct soap *soap, struct tree__setCheckPointData *a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tree__setCheckPointData(struct soap *soap, struct tree__setCheckPointData *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_tree__setCheckPointData);
	soap_out_tree__setCheckPointData(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tree__setCheckPointData(struct soap *soap, const char *tag, int id, const struct tree__setCheckPointData *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tree__setCheckPointData), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct tree__setCheckPointData * SOAP_FMAC4 soap_get_tree__setCheckPointData(struct soap *soap, struct tree__setCheckPointData *p, const char *tag, const char *type)
{
	if ((p = soap_in_tree__setCheckPointData(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct tree__setCheckPointData * SOAP_FMAC4 soap_in_tree__setCheckPointData(struct soap *soap, const char *tag, struct tree__setCheckPointData *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct tree__setCheckPointData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tree__setCheckPointData, sizeof(struct tree__setCheckPointData), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tree__setCheckPointData(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct tree__setCheckPointData *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tree__setCheckPointData, sizeof(struct tree__setCheckPointData), 0), SOAP_TYPE_tree__setCheckPointData, sizeof(struct tree__setCheckPointData));
		if (soap->alloced)
			soap_default_tree__setCheckPointData(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tree__findServiceData(struct soap *soap, struct tree__findServiceData const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_tree__findServiceData))
		soap_mark_tree__findServiceData(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_tree__findServiceData(struct soap *soap, const struct tree__findServiceData *a)
{
	soap_embedded(soap, &a->in0, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tree__findServiceData(struct soap *soap, struct tree__findServiceData *a)
{
	soap_default_xsd__string(soap, &a->in0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tree__findServiceData(struct soap *soap, struct tree__findServiceData *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_tree__findServiceData);
	soap_out_tree__findServiceData(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tree__findServiceData(struct soap *soap, const char *tag, int id, const struct tree__findServiceData *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tree__findServiceData), type);
	soap_out_xsd__string(soap, "in0", -1, &a->in0, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct tree__findServiceData * SOAP_FMAC4 soap_get_tree__findServiceData(struct soap *soap, struct tree__findServiceData *p, const char *tag, const char *type)
{
	if ((p = soap_in_tree__findServiceData(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct tree__findServiceData * SOAP_FMAC4 soap_in_tree__findServiceData(struct soap *soap, const char *tag, struct tree__findServiceData *a, const char *type)
{
	short soap_flag_in0 = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct tree__findServiceData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tree__findServiceData, sizeof(struct tree__findServiceData), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tree__findServiceData(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in0 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "in0", &a->in0, "xsd:string"))
				{	soap_flag_in0 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct tree__findServiceData *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tree__findServiceData, sizeof(struct tree__findServiceData), 0), SOAP_TYPE_tree__findServiceData, sizeof(struct tree__findServiceData));
		if (soap->alloced)
			soap_default_tree__findServiceData(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tree__getInputFile(struct soap *soap, struct tree__getInputFile const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_tree__getInputFile))
		soap_mark_tree__getInputFile(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_tree__getInputFile(struct soap *soap, const struct tree__getInputFile *a)
{
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tree__getInputFile(struct soap *soap, struct tree__getInputFile *a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tree__getInputFile(struct soap *soap, struct tree__getInputFile *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_tree__getInputFile);
	soap_out_tree__getInputFile(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tree__getInputFile(struct soap *soap, const char *tag, int id, const struct tree__getInputFile *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tree__getInputFile), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct tree__getInputFile * SOAP_FMAC4 soap_get_tree__getInputFile(struct soap *soap, struct tree__getInputFile *p, const char *tag, const char *type)
{
	if ((p = soap_in_tree__getInputFile(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct tree__getInputFile * SOAP_FMAC4 soap_in_tree__getInputFile(struct soap *soap, const char *tag, struct tree__getInputFile *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct tree__getInputFile *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tree__getInputFile, sizeof(struct tree__getInputFile), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tree__getInputFile(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct tree__getInputFile *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tree__getInputFile, sizeof(struct tree__getInputFile), 0), SOAP_TYPE_tree__getInputFile, sizeof(struct tree__getInputFile));
		if (soap->alloced)
			soap_default_tree__getInputFile(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tree__getChildNodes(struct soap *soap, struct tree__getChildNodes const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_tree__getChildNodes))
		soap_mark_tree__getChildNodes(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_tree__getChildNodes(struct soap *soap, const struct tree__getChildNodes *a)
{
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tree__getChildNodes(struct soap *soap, struct tree__getChildNodes *a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tree__getChildNodes(struct soap *soap, struct tree__getChildNodes *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_tree__getChildNodes);
	soap_out_tree__getChildNodes(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tree__getChildNodes(struct soap *soap, const char *tag, int id, const struct tree__getChildNodes *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tree__getChildNodes), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct tree__getChildNodes * SOAP_FMAC4 soap_get_tree__getChildNodes(struct soap *soap, struct tree__getChildNodes *p, const char *tag, const char *type)
{
	if ((p = soap_in_tree__getChildNodes(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct tree__getChildNodes * SOAP_FMAC4 soap_in_tree__getChildNodes(struct soap *soap, const char *tag, struct tree__getChildNodes *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct tree__getChildNodes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tree__getChildNodes, sizeof(struct tree__getChildNodes), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tree__getChildNodes(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct tree__getChildNodes *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tree__getChildNodes, sizeof(struct tree__getChildNodes), 0), SOAP_TYPE_tree__getChildNodes, sizeof(struct tree__getChildNodes));
		if (soap->alloced)
			soap_default_tree__getChildNodes(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tree__requestTerminationAfter(struct soap *soap, struct tree__requestTerminationAfter const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_tree__requestTerminationAfter))
		soap_mark_tree__requestTerminationAfter(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_tree__requestTerminationAfter(struct soap *soap, const struct tree__requestTerminationAfter *a)
{
	soap_embedded(soap, &a->in0, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tree__requestTerminationAfter(struct soap *soap, struct tree__requestTerminationAfter *a)
{
	soap_default_xsd__string(soap, &a->in0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tree__requestTerminationAfter(struct soap *soap, struct tree__requestTerminationAfter *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_tree__requestTerminationAfter);
	soap_out_tree__requestTerminationAfter(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tree__requestTerminationAfter(struct soap *soap, const char *tag, int id, const struct tree__requestTerminationAfter *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tree__requestTerminationAfter), type);
	soap_out_xsd__string(soap, "in0", -1, &a->in0, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct tree__requestTerminationAfter * SOAP_FMAC4 soap_get_tree__requestTerminationAfter(struct soap *soap, struct tree__requestTerminationAfter *p, const char *tag, const char *type)
{
	if ((p = soap_in_tree__requestTerminationAfter(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct tree__requestTerminationAfter * SOAP_FMAC4 soap_in_tree__requestTerminationAfter(struct soap *soap, const char *tag, struct tree__requestTerminationAfter *a, const char *type)
{
	short soap_flag_in0 = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct tree__requestTerminationAfter *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tree__requestTerminationAfter, sizeof(struct tree__requestTerminationAfter), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tree__requestTerminationAfter(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in0 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "in0", &a->in0, "xsd:string"))
				{	soap_flag_in0 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct tree__requestTerminationAfter *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tree__requestTerminationAfter, sizeof(struct tree__requestTerminationAfter), 0), SOAP_TYPE_tree__requestTerminationAfter, sizeof(struct tree__requestTerminationAfter));
		if (soap->alloced)
			soap_default_tree__requestTerminationAfter(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_fact__requestTerminationAfter(struct soap *soap, struct fact__requestTerminationAfter const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_fact__requestTerminationAfter))
		soap_mark_fact__requestTerminationAfter(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_fact__requestTerminationAfter(struct soap *soap, const struct fact__requestTerminationAfter *a)
{
	soap_embedded(soap, &a->in0, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fact__requestTerminationAfter(struct soap *soap, struct fact__requestTerminationAfter *a)
{
	soap_default_xsd__string(soap, &a->in0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fact__requestTerminationAfter(struct soap *soap, struct fact__requestTerminationAfter *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_fact__requestTerminationAfter);
	soap_out_fact__requestTerminationAfter(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fact__requestTerminationAfter(struct soap *soap, const char *tag, int id, const struct fact__requestTerminationAfter *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fact__requestTerminationAfter), type);
	soap_out_xsd__string(soap, "in0", -1, &a->in0, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct fact__requestTerminationAfter * SOAP_FMAC4 soap_get_fact__requestTerminationAfter(struct soap *soap, struct fact__requestTerminationAfter *p, const char *tag, const char *type)
{
	if ((p = soap_in_fact__requestTerminationAfter(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct fact__requestTerminationAfter * SOAP_FMAC4 soap_in_fact__requestTerminationAfter(struct soap *soap, const char *tag, struct fact__requestTerminationAfter *a, const char *type)
{
	short soap_flag_in0 = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct fact__requestTerminationAfter *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fact__requestTerminationAfter, sizeof(struct fact__requestTerminationAfter), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_fact__requestTerminationAfter(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in0 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "in0", &a->in0, "xsd:string"))
				{	soap_flag_in0 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct fact__requestTerminationAfter *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fact__requestTerminationAfter, sizeof(struct fact__requestTerminationAfter), 0), SOAP_TYPE_fact__requestTerminationAfter, sizeof(struct fact__requestTerminationAfter));
		if (soap->alloced)
			soap_default_fact__requestTerminationAfter(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_fact__requestTerminationBefore(struct soap *soap, struct fact__requestTerminationBefore const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_fact__requestTerminationBefore))
		soap_mark_fact__requestTerminationBefore(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_fact__requestTerminationBefore(struct soap *soap, const struct fact__requestTerminationBefore *a)
{
	soap_embedded(soap, &a->in0, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fact__requestTerminationBefore(struct soap *soap, struct fact__requestTerminationBefore *a)
{
	soap_default_xsd__string(soap, &a->in0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fact__requestTerminationBefore(struct soap *soap, struct fact__requestTerminationBefore *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_fact__requestTerminationBefore);
	soap_out_fact__requestTerminationBefore(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fact__requestTerminationBefore(struct soap *soap, const char *tag, int id, const struct fact__requestTerminationBefore *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fact__requestTerminationBefore), type);
	soap_out_xsd__string(soap, "in0", -1, &a->in0, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct fact__requestTerminationBefore * SOAP_FMAC4 soap_get_fact__requestTerminationBefore(struct soap *soap, struct fact__requestTerminationBefore *p, const char *tag, const char *type)
{
	if ((p = soap_in_fact__requestTerminationBefore(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct fact__requestTerminationBefore * SOAP_FMAC4 soap_in_fact__requestTerminationBefore(struct soap *soap, const char *tag, struct fact__requestTerminationBefore *a, const char *type)
{
	short soap_flag_in0 = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct fact__requestTerminationBefore *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fact__requestTerminationBefore, sizeof(struct fact__requestTerminationBefore), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_fact__requestTerminationBefore(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in0 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "in0", &a->in0, "xsd:string"))
				{	soap_flag_in0 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct fact__requestTerminationBefore *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fact__requestTerminationBefore, sizeof(struct fact__requestTerminationBefore), 0), SOAP_TYPE_fact__requestTerminationBefore, sizeof(struct fact__requestTerminationBefore));
		if (soap->alloced)
			soap_default_fact__requestTerminationBefore(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_fact__getActiveTrees(struct soap *soap, struct fact__getActiveTrees const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_fact__getActiveTrees))
		soap_mark_fact__getActiveTrees(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_fact__getActiveTrees(struct soap *soap, const struct fact__getActiveTrees *a)
{
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fact__getActiveTrees(struct soap *soap, struct fact__getActiveTrees *a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fact__getActiveTrees(struct soap *soap, struct fact__getActiveTrees *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_fact__getActiveTrees);
	soap_out_fact__getActiveTrees(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fact__getActiveTrees(struct soap *soap, const char *tag, int id, const struct fact__getActiveTrees *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fact__getActiveTrees), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct fact__getActiveTrees * SOAP_FMAC4 soap_get_fact__getActiveTrees(struct soap *soap, struct fact__getActiveTrees *p, const char *tag, const char *type)
{
	if ((p = soap_in_fact__getActiveTrees(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct fact__getActiveTrees * SOAP_FMAC4 soap_in_fact__getActiveTrees(struct soap *soap, const char *tag, struct fact__getActiveTrees *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct fact__getActiveTrees *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fact__getActiveTrees, sizeof(struct fact__getActiveTrees), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_fact__getActiveTrees(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct fact__getActiveTrees *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fact__getActiveTrees, sizeof(struct fact__getActiveTrees), 0), SOAP_TYPE_fact__getActiveTrees, sizeof(struct fact__getActiveTrees));
		if (soap->alloced)
			soap_default_fact__getActiveTrees(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_fact__findServiceData(struct soap *soap, struct fact__findServiceData const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_fact__findServiceData))
		soap_mark_fact__findServiceData(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_fact__findServiceData(struct soap *soap, const struct fact__findServiceData *a)
{
	soap_embedded(soap, &a->in0, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->in0);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fact__findServiceData(struct soap *soap, struct fact__findServiceData *a)
{
	soap_default_xsd__string(soap, &a->in0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fact__findServiceData(struct soap *soap, struct fact__findServiceData *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_fact__findServiceData);
	soap_out_fact__findServiceData(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fact__findServiceData(struct soap *soap, const char *tag, int id, const struct fact__findServiceData *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fact__findServiceData), type);
	soap_out_xsd__string(soap, "in0", -1, &a->in0, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct fact__findServiceData * SOAP_FMAC4 soap_get_fact__findServiceData(struct soap *soap, struct fact__findServiceData *p, const char *tag, const char *type)
{
	if ((p = soap_in_fact__findServiceData(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct fact__findServiceData * SOAP_FMAC4 soap_in_fact__findServiceData(struct soap *soap, const char *tag, struct fact__findServiceData *a, const char *type)
{
	short soap_flag_in0 = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct fact__findServiceData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fact__findServiceData, sizeof(struct fact__findServiceData), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_fact__findServiceData(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in0 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "in0", &a->in0, "xsd:string"))
				{	soap_flag_in0 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct fact__findServiceData *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fact__findServiceData, sizeof(struct fact__findServiceData), 0), SOAP_TYPE_fact__findServiceData, sizeof(struct fact__findServiceData));
		if (soap->alloced)
			soap_default_fact__findServiceData(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_fact__destroy(struct soap *soap, struct fact__destroy const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_fact__destroy))
		soap_mark_fact__destroy(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_fact__destroy(struct soap *soap, const struct fact__destroy *a)
{
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fact__destroy(struct soap *soap, struct fact__destroy *a)
{
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fact__destroy(struct soap *soap, struct fact__destroy *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_fact__destroy);
	soap_out_fact__destroy(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fact__destroy(struct soap *soap, const char *tag, int id, const struct fact__destroy *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fact__destroy), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct fact__destroy * SOAP_FMAC4 soap_get_fact__destroy(struct soap *soap, struct fact__destroy *p, const char *tag, const char *type)
{
	if ((p = soap_in_fact__destroy(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct fact__destroy * SOAP_FMAC4 soap_in_fact__destroy(struct soap *soap, const char *tag, struct fact__destroy *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct fact__destroy *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fact__destroy, sizeof(struct fact__destroy), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_fact__destroy(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct fact__destroy *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fact__destroy, sizeof(struct fact__destroy), 0), SOAP_TYPE_fact__destroy, sizeof(struct fact__destroy));
		if (soap->alloced)
			soap_default_fact__destroy(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_fact__findByHandle(struct soap *soap, struct fact__findByHandle const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_fact__findByHandle))
		soap_mark_fact__findByHandle(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_fact__findByHandle(struct soap *soap, const struct fact__findByHandle *a)
{
	soap_embedded(soap, &a->in0, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->in0);
	soap_embedded(soap, &a->in1, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->in1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fact__findByHandle(struct soap *soap, struct fact__findByHandle *a)
{
	soap_default_xsd__string(soap, &a->in0);
	soap_default_xsd__string(soap, &a->in1);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fact__findByHandle(struct soap *soap, struct fact__findByHandle *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_fact__findByHandle);
	soap_out_fact__findByHandle(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fact__findByHandle(struct soap *soap, const char *tag, int id, const struct fact__findByHandle *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fact__findByHandle), type);
	soap_out_xsd__string(soap, "in0", -1, &a->in0, "xsd:string");
	soap_out_xsd__string(soap, "in1", -1, &a->in1, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct fact__findByHandle * SOAP_FMAC4 soap_get_fact__findByHandle(struct soap *soap, struct fact__findByHandle *p, const char *tag, const char *type)
{
	if ((p = soap_in_fact__findByHandle(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct fact__findByHandle * SOAP_FMAC4 soap_in_fact__findByHandle(struct soap *soap, const char *tag, struct fact__findByHandle *a, const char *type)
{
	short soap_flag_in0 = 1, soap_flag_in1 = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct fact__findByHandle *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fact__findByHandle, sizeof(struct fact__findByHandle), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_fact__findByHandle(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in0 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "in0", &a->in0, "xsd:string"))
				{	soap_flag_in0 = 0;
					continue;
				}
			if (soap_flag_in1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "in1", &a->in1, "xsd:string"))
				{	soap_flag_in1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct fact__findByHandle *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fact__findByHandle, sizeof(struct fact__findByHandle), 0), SOAP_TYPE_fact__findByHandle, sizeof(struct fact__findByHandle));
		if (soap->alloced)
			soap_default_fact__findByHandle(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_fact__createNewTree(struct soap *soap, struct fact__createNewTree const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_fact__createNewTree))
		soap_mark_fact__createNewTree(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_fact__createNewTree(struct soap *soap, const struct fact__createNewTree *a)
{
	soap_embedded(soap, &a->in0, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->in0);
	soap_embedded(soap, &a->in1, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->in1);
	soap_embedded(soap, &a->in2, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->in2);
	soap_embedded(soap, &a->in3, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->in3);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_fact__createNewTree(struct soap *soap, struct fact__createNewTree *a)
{
	soap_default_xsd__string(soap, &a->in0);
	soap_default_xsd__string(soap, &a->in1);
	soap_default_xsd__string(soap, &a->in2);
	soap_default_xsd__string(soap, &a->in3);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_fact__createNewTree(struct soap *soap, struct fact__createNewTree *a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_fact__createNewTree);
	soap_out_fact__createNewTree(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_fact__createNewTree(struct soap *soap, const char *tag, int id, const struct fact__createNewTree *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_fact__createNewTree), type);
	soap_out_xsd__string(soap, "in0", -1, &a->in0, "xsd:string");
	soap_out_xsd__string(soap, "in1", -1, &a->in1, "xsd:string");
	soap_out_xsd__string(soap, "in2", -1, &a->in2, "xsd:string");
	soap_out_xsd__string(soap, "in3", -1, &a->in3, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct fact__createNewTree * SOAP_FMAC4 soap_get_fact__createNewTree(struct soap *soap, struct fact__createNewTree *p, const char *tag, const char *type)
{
	if ((p = soap_in_fact__createNewTree(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct fact__createNewTree * SOAP_FMAC4 soap_in_fact__createNewTree(struct soap *soap, const char *tag, struct fact__createNewTree *a, const char *type)
{
	short soap_flag_in0 = 1, soap_flag_in1 = 1, soap_flag_in2 = 1, soap_flag_in3 = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct fact__createNewTree *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fact__createNewTree, sizeof(struct fact__createNewTree), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_fact__createNewTree(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_in0 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "in0", &a->in0, "xsd:string"))
				{	soap_flag_in0 = 0;
					continue;
				}
			if (soap_flag_in1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "in1", &a->in1, "xsd:string"))
				{	soap_flag_in1 = 0;
					continue;
				}
			if (soap_flag_in2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "in2", &a->in2, "xsd:string"))
				{	soap_flag_in2 = 0;
					continue;
				}
			if (soap_flag_in3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "in3", &a->in3, "xsd:string"))
				{	soap_flag_in3 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct fact__createNewTree *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_fact__createNewTree, sizeof(struct fact__createNewTree), 0), SOAP_TYPE_fact__createNewTree, sizeof(struct fact__createNewTree));
		if (soap->alloced)
			soap_default_fact__createNewTree(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerToSOAP_ENV__Code))
		soap_mark_PointerToSOAP_ENV__Code(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_mark_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	soap_out_PointerToSOAP_ENV__Code(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_SOAP_ENV__Code, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return soap_out_SOAP_ENV__Code(soap, tag, 0, *a, type);
		soap_set_embedded(soap, pp);
		return soap_out_SOAP_ENV__Code(soap, tag, i, *a, type);
	}
	return soap_out_SOAP_ENV__Code(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_SOAP_ENV__Code, &pp), *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	struct SOAP_ENV__Code *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct SOAP_ENV__Code **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerToSOAP_ENV__Code, sizeof(struct SOAP_ENV__Code *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_SOAP_ENV__Code(soap, tag, NULL, type)))
		{	a = (struct SOAP_ENV__Code **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerToSOAP_ENV__Code, sizeof(struct SOAP_ENV__Code *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerToSOAP_ENV__Code, sizeof(struct SOAP_ENV__Code *), 1), SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default__QName(struct soap *soap, char **a)
{
#ifdef SOAP_DEFAULT__QName
	*a = SOAP_DEFAULT__QName;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE__QName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark__QName(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE__QName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char **a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE__QName);
	soap_out__QName(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotree__addNodeResponse(struct soap *soap, tree__addNodeResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTotree__addNodeResponse))
		soap_mark_PointerTotree__addNodeResponse(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTotree__addNodeResponse(struct soap *soap, tree__addNodeResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tree__addNodeResponse))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTotree__addNodeResponse(struct soap *soap, tree__addNodeResponse **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotree__addNodeResponse(struct soap *soap, tree__addNodeResponse **a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTotree__addNodeResponse);
	soap_out_PointerTotree__addNodeResponse(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotree__addNodeResponse(struct soap *soap, const char *tag, int id, tree__addNodeResponse *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTotree__addNodeResponse);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_tree__addNodeResponse, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_tree__addNodeResponse, &pp), type);
}

SOAP_FMAC3 tree__addNodeResponse ** SOAP_FMAC4 soap_get_PointerTotree__addNodeResponse(struct soap *soap, tree__addNodeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotree__addNodeResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 tree__addNodeResponse ** SOAP_FMAC4 soap_in_PointerTotree__addNodeResponse(struct soap *soap, const char *tag, tree__addNodeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (tree__addNodeResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotree__addNodeResponse, sizeof(tree__addNodeResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (tree__addNodeResponse **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTotree__addNodeResponse, sizeof(tree__addNodeResponse *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (tree__addNodeResponse *)soap_instantiate_tree__addNodeResponse(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (tree__addNodeResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotree__addNodeResponse, sizeof(tree__addNodeResponse *), 1), SOAP_TYPE_tree__addNodeResponse, sizeof(tree__addNodeResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotree__getParentNodeResponse(struct soap *soap, tree__getParentNodeResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTotree__getParentNodeResponse))
		soap_mark_PointerTotree__getParentNodeResponse(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTotree__getParentNodeResponse(struct soap *soap, tree__getParentNodeResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tree__getParentNodeResponse))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTotree__getParentNodeResponse(struct soap *soap, tree__getParentNodeResponse **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotree__getParentNodeResponse(struct soap *soap, tree__getParentNodeResponse **a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTotree__getParentNodeResponse);
	soap_out_PointerTotree__getParentNodeResponse(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotree__getParentNodeResponse(struct soap *soap, const char *tag, int id, tree__getParentNodeResponse *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTotree__getParentNodeResponse);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_tree__getParentNodeResponse, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_tree__getParentNodeResponse, &pp), type);
}

SOAP_FMAC3 tree__getParentNodeResponse ** SOAP_FMAC4 soap_get_PointerTotree__getParentNodeResponse(struct soap *soap, tree__getParentNodeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotree__getParentNodeResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 tree__getParentNodeResponse ** SOAP_FMAC4 soap_in_PointerTotree__getParentNodeResponse(struct soap *soap, const char *tag, tree__getParentNodeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (tree__getParentNodeResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotree__getParentNodeResponse, sizeof(tree__getParentNodeResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (tree__getParentNodeResponse **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTotree__getParentNodeResponse, sizeof(tree__getParentNodeResponse *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (tree__getParentNodeResponse *)soap_instantiate_tree__getParentNodeResponse(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (tree__getParentNodeResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotree__getParentNodeResponse, sizeof(tree__getParentNodeResponse *), 1), SOAP_TYPE_tree__getParentNodeResponse, sizeof(tree__getParentNodeResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotree__getCheckPointDataResponse(struct soap *soap, tree__getCheckPointDataResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTotree__getCheckPointDataResponse))
		soap_mark_PointerTotree__getCheckPointDataResponse(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTotree__getCheckPointDataResponse(struct soap *soap, tree__getCheckPointDataResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tree__getCheckPointDataResponse))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTotree__getCheckPointDataResponse(struct soap *soap, tree__getCheckPointDataResponse **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotree__getCheckPointDataResponse(struct soap *soap, tree__getCheckPointDataResponse **a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTotree__getCheckPointDataResponse);
	soap_out_PointerTotree__getCheckPointDataResponse(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotree__getCheckPointDataResponse(struct soap *soap, const char *tag, int id, tree__getCheckPointDataResponse *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTotree__getCheckPointDataResponse);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_tree__getCheckPointDataResponse, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_tree__getCheckPointDataResponse, &pp), type);
}

SOAP_FMAC3 tree__getCheckPointDataResponse ** SOAP_FMAC4 soap_get_PointerTotree__getCheckPointDataResponse(struct soap *soap, tree__getCheckPointDataResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotree__getCheckPointDataResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 tree__getCheckPointDataResponse ** SOAP_FMAC4 soap_in_PointerTotree__getCheckPointDataResponse(struct soap *soap, const char *tag, tree__getCheckPointDataResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (tree__getCheckPointDataResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotree__getCheckPointDataResponse, sizeof(tree__getCheckPointDataResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (tree__getCheckPointDataResponse **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTotree__getCheckPointDataResponse, sizeof(tree__getCheckPointDataResponse *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (tree__getCheckPointDataResponse *)soap_instantiate_tree__getCheckPointDataResponse(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (tree__getCheckPointDataResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotree__getCheckPointDataResponse, sizeof(tree__getCheckPointDataResponse *), 1), SOAP_TYPE_tree__getCheckPointDataResponse, sizeof(tree__getCheckPointDataResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotree__requestTerminationBeforeResponse(struct soap *soap, tree__requestTerminationBeforeResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTotree__requestTerminationBeforeResponse))
		soap_mark_PointerTotree__requestTerminationBeforeResponse(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTotree__requestTerminationBeforeResponse(struct soap *soap, tree__requestTerminationBeforeResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tree__requestTerminationBeforeResponse))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTotree__requestTerminationBeforeResponse(struct soap *soap, tree__requestTerminationBeforeResponse **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotree__requestTerminationBeforeResponse(struct soap *soap, tree__requestTerminationBeforeResponse **a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTotree__requestTerminationBeforeResponse);
	soap_out_PointerTotree__requestTerminationBeforeResponse(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotree__requestTerminationBeforeResponse(struct soap *soap, const char *tag, int id, tree__requestTerminationBeforeResponse *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTotree__requestTerminationBeforeResponse);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_tree__requestTerminationBeforeResponse, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_tree__requestTerminationBeforeResponse, &pp), type);
}

SOAP_FMAC3 tree__requestTerminationBeforeResponse ** SOAP_FMAC4 soap_get_PointerTotree__requestTerminationBeforeResponse(struct soap *soap, tree__requestTerminationBeforeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotree__requestTerminationBeforeResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 tree__requestTerminationBeforeResponse ** SOAP_FMAC4 soap_in_PointerTotree__requestTerminationBeforeResponse(struct soap *soap, const char *tag, tree__requestTerminationBeforeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (tree__requestTerminationBeforeResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotree__requestTerminationBeforeResponse, sizeof(tree__requestTerminationBeforeResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (tree__requestTerminationBeforeResponse **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTotree__requestTerminationBeforeResponse, sizeof(tree__requestTerminationBeforeResponse *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (tree__requestTerminationBeforeResponse *)soap_instantiate_tree__requestTerminationBeforeResponse(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (tree__requestTerminationBeforeResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotree__requestTerminationBeforeResponse, sizeof(tree__requestTerminationBeforeResponse *), 1), SOAP_TYPE_tree__requestTerminationBeforeResponse, sizeof(tree__requestTerminationBeforeResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotree__getSteeringCommandsResponse(struct soap *soap, tree__getSteeringCommandsResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTotree__getSteeringCommandsResponse))
		soap_mark_PointerTotree__getSteeringCommandsResponse(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTotree__getSteeringCommandsResponse(struct soap *soap, tree__getSteeringCommandsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tree__getSteeringCommandsResponse))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTotree__getSteeringCommandsResponse(struct soap *soap, tree__getSteeringCommandsResponse **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotree__getSteeringCommandsResponse(struct soap *soap, tree__getSteeringCommandsResponse **a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTotree__getSteeringCommandsResponse);
	soap_out_PointerTotree__getSteeringCommandsResponse(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotree__getSteeringCommandsResponse(struct soap *soap, const char *tag, int id, tree__getSteeringCommandsResponse *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTotree__getSteeringCommandsResponse);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_tree__getSteeringCommandsResponse, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_tree__getSteeringCommandsResponse, &pp), type);
}

SOAP_FMAC3 tree__getSteeringCommandsResponse ** SOAP_FMAC4 soap_get_PointerTotree__getSteeringCommandsResponse(struct soap *soap, tree__getSteeringCommandsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotree__getSteeringCommandsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 tree__getSteeringCommandsResponse ** SOAP_FMAC4 soap_in_PointerTotree__getSteeringCommandsResponse(struct soap *soap, const char *tag, tree__getSteeringCommandsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (tree__getSteeringCommandsResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotree__getSteeringCommandsResponse, sizeof(tree__getSteeringCommandsResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (tree__getSteeringCommandsResponse **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTotree__getSteeringCommandsResponse, sizeof(tree__getSteeringCommandsResponse *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (tree__getSteeringCommandsResponse *)soap_instantiate_tree__getSteeringCommandsResponse(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (tree__getSteeringCommandsResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotree__getSteeringCommandsResponse, sizeof(tree__getSteeringCommandsResponse *), 1), SOAP_TYPE_tree__getSteeringCommandsResponse, sizeof(tree__getSteeringCommandsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotree__destroyResponse(struct soap *soap, tree__destroyResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTotree__destroyResponse))
		soap_mark_PointerTotree__destroyResponse(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTotree__destroyResponse(struct soap *soap, tree__destroyResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tree__destroyResponse))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTotree__destroyResponse(struct soap *soap, tree__destroyResponse **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotree__destroyResponse(struct soap *soap, tree__destroyResponse **a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTotree__destroyResponse);
	soap_out_PointerTotree__destroyResponse(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotree__destroyResponse(struct soap *soap, const char *tag, int id, tree__destroyResponse *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTotree__destroyResponse);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_tree__destroyResponse, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_tree__destroyResponse, &pp), type);
}

SOAP_FMAC3 tree__destroyResponse ** SOAP_FMAC4 soap_get_PointerTotree__destroyResponse(struct soap *soap, tree__destroyResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotree__destroyResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 tree__destroyResponse ** SOAP_FMAC4 soap_in_PointerTotree__destroyResponse(struct soap *soap, const char *tag, tree__destroyResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (tree__destroyResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotree__destroyResponse, sizeof(tree__destroyResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (tree__destroyResponse **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTotree__destroyResponse, sizeof(tree__destroyResponse *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (tree__destroyResponse *)soap_instantiate_tree__destroyResponse(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (tree__destroyResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotree__destroyResponse, sizeof(tree__destroyResponse *), 1), SOAP_TYPE_tree__destroyResponse, sizeof(tree__destroyResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotree__setCheckPointDataResponse(struct soap *soap, tree__setCheckPointDataResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTotree__setCheckPointDataResponse))
		soap_mark_PointerTotree__setCheckPointDataResponse(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTotree__setCheckPointDataResponse(struct soap *soap, tree__setCheckPointDataResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tree__setCheckPointDataResponse))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTotree__setCheckPointDataResponse(struct soap *soap, tree__setCheckPointDataResponse **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotree__setCheckPointDataResponse(struct soap *soap, tree__setCheckPointDataResponse **a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTotree__setCheckPointDataResponse);
	soap_out_PointerTotree__setCheckPointDataResponse(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotree__setCheckPointDataResponse(struct soap *soap, const char *tag, int id, tree__setCheckPointDataResponse *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTotree__setCheckPointDataResponse);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_tree__setCheckPointDataResponse, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_tree__setCheckPointDataResponse, &pp), type);
}

SOAP_FMAC3 tree__setCheckPointDataResponse ** SOAP_FMAC4 soap_get_PointerTotree__setCheckPointDataResponse(struct soap *soap, tree__setCheckPointDataResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotree__setCheckPointDataResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 tree__setCheckPointDataResponse ** SOAP_FMAC4 soap_in_PointerTotree__setCheckPointDataResponse(struct soap *soap, const char *tag, tree__setCheckPointDataResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (tree__setCheckPointDataResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotree__setCheckPointDataResponse, sizeof(tree__setCheckPointDataResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (tree__setCheckPointDataResponse **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTotree__setCheckPointDataResponse, sizeof(tree__setCheckPointDataResponse *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (tree__setCheckPointDataResponse *)soap_instantiate_tree__setCheckPointDataResponse(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (tree__setCheckPointDataResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotree__setCheckPointDataResponse, sizeof(tree__setCheckPointDataResponse *), 1), SOAP_TYPE_tree__setCheckPointDataResponse, sizeof(tree__setCheckPointDataResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotree__findServiceDataResponse(struct soap *soap, tree__findServiceDataResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTotree__findServiceDataResponse))
		soap_mark_PointerTotree__findServiceDataResponse(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTotree__findServiceDataResponse(struct soap *soap, tree__findServiceDataResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tree__findServiceDataResponse))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTotree__findServiceDataResponse(struct soap *soap, tree__findServiceDataResponse **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotree__findServiceDataResponse(struct soap *soap, tree__findServiceDataResponse **a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTotree__findServiceDataResponse);
	soap_out_PointerTotree__findServiceDataResponse(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotree__findServiceDataResponse(struct soap *soap, const char *tag, int id, tree__findServiceDataResponse *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTotree__findServiceDataResponse);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_tree__findServiceDataResponse, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_tree__findServiceDataResponse, &pp), type);
}

SOAP_FMAC3 tree__findServiceDataResponse ** SOAP_FMAC4 soap_get_PointerTotree__findServiceDataResponse(struct soap *soap, tree__findServiceDataResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotree__findServiceDataResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 tree__findServiceDataResponse ** SOAP_FMAC4 soap_in_PointerTotree__findServiceDataResponse(struct soap *soap, const char *tag, tree__findServiceDataResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (tree__findServiceDataResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotree__findServiceDataResponse, sizeof(tree__findServiceDataResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (tree__findServiceDataResponse **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTotree__findServiceDataResponse, sizeof(tree__findServiceDataResponse *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (tree__findServiceDataResponse *)soap_instantiate_tree__findServiceDataResponse(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (tree__findServiceDataResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotree__findServiceDataResponse, sizeof(tree__findServiceDataResponse *), 1), SOAP_TYPE_tree__findServiceDataResponse, sizeof(tree__findServiceDataResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotree__getInputFileResponse(struct soap *soap, tree__getInputFileResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTotree__getInputFileResponse))
		soap_mark_PointerTotree__getInputFileResponse(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTotree__getInputFileResponse(struct soap *soap, tree__getInputFileResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tree__getInputFileResponse))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTotree__getInputFileResponse(struct soap *soap, tree__getInputFileResponse **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotree__getInputFileResponse(struct soap *soap, tree__getInputFileResponse **a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTotree__getInputFileResponse);
	soap_out_PointerTotree__getInputFileResponse(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotree__getInputFileResponse(struct soap *soap, const char *tag, int id, tree__getInputFileResponse *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTotree__getInputFileResponse);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_tree__getInputFileResponse, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_tree__getInputFileResponse, &pp), type);
}

SOAP_FMAC3 tree__getInputFileResponse ** SOAP_FMAC4 soap_get_PointerTotree__getInputFileResponse(struct soap *soap, tree__getInputFileResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotree__getInputFileResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 tree__getInputFileResponse ** SOAP_FMAC4 soap_in_PointerTotree__getInputFileResponse(struct soap *soap, const char *tag, tree__getInputFileResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (tree__getInputFileResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotree__getInputFileResponse, sizeof(tree__getInputFileResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (tree__getInputFileResponse **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTotree__getInputFileResponse, sizeof(tree__getInputFileResponse *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (tree__getInputFileResponse *)soap_instantiate_tree__getInputFileResponse(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (tree__getInputFileResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotree__getInputFileResponse, sizeof(tree__getInputFileResponse *), 1), SOAP_TYPE_tree__getInputFileResponse, sizeof(tree__getInputFileResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotree__getChildNodesResponse(struct soap *soap, tree__getChildNodesResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTotree__getChildNodesResponse))
		soap_mark_PointerTotree__getChildNodesResponse(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTotree__getChildNodesResponse(struct soap *soap, tree__getChildNodesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tree__getChildNodesResponse))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTotree__getChildNodesResponse(struct soap *soap, tree__getChildNodesResponse **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotree__getChildNodesResponse(struct soap *soap, tree__getChildNodesResponse **a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTotree__getChildNodesResponse);
	soap_out_PointerTotree__getChildNodesResponse(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotree__getChildNodesResponse(struct soap *soap, const char *tag, int id, tree__getChildNodesResponse *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTotree__getChildNodesResponse);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_tree__getChildNodesResponse, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_tree__getChildNodesResponse, &pp), type);
}

SOAP_FMAC3 tree__getChildNodesResponse ** SOAP_FMAC4 soap_get_PointerTotree__getChildNodesResponse(struct soap *soap, tree__getChildNodesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotree__getChildNodesResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 tree__getChildNodesResponse ** SOAP_FMAC4 soap_in_PointerTotree__getChildNodesResponse(struct soap *soap, const char *tag, tree__getChildNodesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (tree__getChildNodesResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotree__getChildNodesResponse, sizeof(tree__getChildNodesResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (tree__getChildNodesResponse **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTotree__getChildNodesResponse, sizeof(tree__getChildNodesResponse *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (tree__getChildNodesResponse *)soap_instantiate_tree__getChildNodesResponse(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (tree__getChildNodesResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotree__getChildNodesResponse, sizeof(tree__getChildNodesResponse *), 1), SOAP_TYPE_tree__getChildNodesResponse, sizeof(tree__getChildNodesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotree__requestTerminationAfterResponse(struct soap *soap, tree__requestTerminationAfterResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTotree__requestTerminationAfterResponse))
		soap_mark_PointerTotree__requestTerminationAfterResponse(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTotree__requestTerminationAfterResponse(struct soap *soap, tree__requestTerminationAfterResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tree__requestTerminationAfterResponse))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTotree__requestTerminationAfterResponse(struct soap *soap, tree__requestTerminationAfterResponse **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotree__requestTerminationAfterResponse(struct soap *soap, tree__requestTerminationAfterResponse **a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTotree__requestTerminationAfterResponse);
	soap_out_PointerTotree__requestTerminationAfterResponse(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotree__requestTerminationAfterResponse(struct soap *soap, const char *tag, int id, tree__requestTerminationAfterResponse *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTotree__requestTerminationAfterResponse);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_tree__requestTerminationAfterResponse, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_tree__requestTerminationAfterResponse, &pp), type);
}

SOAP_FMAC3 tree__requestTerminationAfterResponse ** SOAP_FMAC4 soap_get_PointerTotree__requestTerminationAfterResponse(struct soap *soap, tree__requestTerminationAfterResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotree__requestTerminationAfterResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 tree__requestTerminationAfterResponse ** SOAP_FMAC4 soap_in_PointerTotree__requestTerminationAfterResponse(struct soap *soap, const char *tag, tree__requestTerminationAfterResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (tree__requestTerminationAfterResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotree__requestTerminationAfterResponse, sizeof(tree__requestTerminationAfterResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (tree__requestTerminationAfterResponse **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTotree__requestTerminationAfterResponse, sizeof(tree__requestTerminationAfterResponse *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (tree__requestTerminationAfterResponse *)soap_instantiate_tree__requestTerminationAfterResponse(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (tree__requestTerminationAfterResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotree__requestTerminationAfterResponse, sizeof(tree__requestTerminationAfterResponse *), 1), SOAP_TYPE_tree__requestTerminationAfterResponse, sizeof(tree__requestTerminationAfterResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofact__requestTerminationAfterResponse(struct soap *soap, fact__requestTerminationAfterResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTofact__requestTerminationAfterResponse))
		soap_mark_PointerTofact__requestTerminationAfterResponse(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTofact__requestTerminationAfterResponse(struct soap *soap, fact__requestTerminationAfterResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_fact__requestTerminationAfterResponse))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTofact__requestTerminationAfterResponse(struct soap *soap, fact__requestTerminationAfterResponse **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofact__requestTerminationAfterResponse(struct soap *soap, fact__requestTerminationAfterResponse **a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTofact__requestTerminationAfterResponse);
	soap_out_PointerTofact__requestTerminationAfterResponse(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofact__requestTerminationAfterResponse(struct soap *soap, const char *tag, int id, fact__requestTerminationAfterResponse *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTofact__requestTerminationAfterResponse);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_fact__requestTerminationAfterResponse, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_fact__requestTerminationAfterResponse, &pp), type);
}

SOAP_FMAC3 fact__requestTerminationAfterResponse ** SOAP_FMAC4 soap_get_PointerTofact__requestTerminationAfterResponse(struct soap *soap, fact__requestTerminationAfterResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofact__requestTerminationAfterResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 fact__requestTerminationAfterResponse ** SOAP_FMAC4 soap_in_PointerTofact__requestTerminationAfterResponse(struct soap *soap, const char *tag, fact__requestTerminationAfterResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (fact__requestTerminationAfterResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTofact__requestTerminationAfterResponse, sizeof(fact__requestTerminationAfterResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (fact__requestTerminationAfterResponse **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTofact__requestTerminationAfterResponse, sizeof(fact__requestTerminationAfterResponse *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (fact__requestTerminationAfterResponse *)soap_instantiate_fact__requestTerminationAfterResponse(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (fact__requestTerminationAfterResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTofact__requestTerminationAfterResponse, sizeof(fact__requestTerminationAfterResponse *), 1), SOAP_TYPE_fact__requestTerminationAfterResponse, sizeof(fact__requestTerminationAfterResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofact__requestTerminationBeforeResponse(struct soap *soap, fact__requestTerminationBeforeResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTofact__requestTerminationBeforeResponse))
		soap_mark_PointerTofact__requestTerminationBeforeResponse(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTofact__requestTerminationBeforeResponse(struct soap *soap, fact__requestTerminationBeforeResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_fact__requestTerminationBeforeResponse))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTofact__requestTerminationBeforeResponse(struct soap *soap, fact__requestTerminationBeforeResponse **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofact__requestTerminationBeforeResponse(struct soap *soap, fact__requestTerminationBeforeResponse **a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTofact__requestTerminationBeforeResponse);
	soap_out_PointerTofact__requestTerminationBeforeResponse(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofact__requestTerminationBeforeResponse(struct soap *soap, const char *tag, int id, fact__requestTerminationBeforeResponse *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTofact__requestTerminationBeforeResponse);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_fact__requestTerminationBeforeResponse, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_fact__requestTerminationBeforeResponse, &pp), type);
}

SOAP_FMAC3 fact__requestTerminationBeforeResponse ** SOAP_FMAC4 soap_get_PointerTofact__requestTerminationBeforeResponse(struct soap *soap, fact__requestTerminationBeforeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofact__requestTerminationBeforeResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 fact__requestTerminationBeforeResponse ** SOAP_FMAC4 soap_in_PointerTofact__requestTerminationBeforeResponse(struct soap *soap, const char *tag, fact__requestTerminationBeforeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (fact__requestTerminationBeforeResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTofact__requestTerminationBeforeResponse, sizeof(fact__requestTerminationBeforeResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (fact__requestTerminationBeforeResponse **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTofact__requestTerminationBeforeResponse, sizeof(fact__requestTerminationBeforeResponse *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (fact__requestTerminationBeforeResponse *)soap_instantiate_fact__requestTerminationBeforeResponse(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (fact__requestTerminationBeforeResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTofact__requestTerminationBeforeResponse, sizeof(fact__requestTerminationBeforeResponse *), 1), SOAP_TYPE_fact__requestTerminationBeforeResponse, sizeof(fact__requestTerminationBeforeResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofact__getActiveTreesResponse(struct soap *soap, fact__getActiveTreesResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTofact__getActiveTreesResponse))
		soap_mark_PointerTofact__getActiveTreesResponse(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTofact__getActiveTreesResponse(struct soap *soap, fact__getActiveTreesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_fact__getActiveTreesResponse))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTofact__getActiveTreesResponse(struct soap *soap, fact__getActiveTreesResponse **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofact__getActiveTreesResponse(struct soap *soap, fact__getActiveTreesResponse **a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTofact__getActiveTreesResponse);
	soap_out_PointerTofact__getActiveTreesResponse(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofact__getActiveTreesResponse(struct soap *soap, const char *tag, int id, fact__getActiveTreesResponse *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTofact__getActiveTreesResponse);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_fact__getActiveTreesResponse, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_fact__getActiveTreesResponse, &pp), type);
}

SOAP_FMAC3 fact__getActiveTreesResponse ** SOAP_FMAC4 soap_get_PointerTofact__getActiveTreesResponse(struct soap *soap, fact__getActiveTreesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofact__getActiveTreesResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 fact__getActiveTreesResponse ** SOAP_FMAC4 soap_in_PointerTofact__getActiveTreesResponse(struct soap *soap, const char *tag, fact__getActiveTreesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (fact__getActiveTreesResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTofact__getActiveTreesResponse, sizeof(fact__getActiveTreesResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (fact__getActiveTreesResponse **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTofact__getActiveTreesResponse, sizeof(fact__getActiveTreesResponse *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (fact__getActiveTreesResponse *)soap_instantiate_fact__getActiveTreesResponse(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (fact__getActiveTreesResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTofact__getActiveTreesResponse, sizeof(fact__getActiveTreesResponse *), 1), SOAP_TYPE_fact__getActiveTreesResponse, sizeof(fact__getActiveTreesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofact__findServiceDataResponse(struct soap *soap, fact__findServiceDataResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTofact__findServiceDataResponse))
		soap_mark_PointerTofact__findServiceDataResponse(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTofact__findServiceDataResponse(struct soap *soap, fact__findServiceDataResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_fact__findServiceDataResponse))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTofact__findServiceDataResponse(struct soap *soap, fact__findServiceDataResponse **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofact__findServiceDataResponse(struct soap *soap, fact__findServiceDataResponse **a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTofact__findServiceDataResponse);
	soap_out_PointerTofact__findServiceDataResponse(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofact__findServiceDataResponse(struct soap *soap, const char *tag, int id, fact__findServiceDataResponse *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTofact__findServiceDataResponse);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_fact__findServiceDataResponse, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_fact__findServiceDataResponse, &pp), type);
}

SOAP_FMAC3 fact__findServiceDataResponse ** SOAP_FMAC4 soap_get_PointerTofact__findServiceDataResponse(struct soap *soap, fact__findServiceDataResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofact__findServiceDataResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 fact__findServiceDataResponse ** SOAP_FMAC4 soap_in_PointerTofact__findServiceDataResponse(struct soap *soap, const char *tag, fact__findServiceDataResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (fact__findServiceDataResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTofact__findServiceDataResponse, sizeof(fact__findServiceDataResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (fact__findServiceDataResponse **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTofact__findServiceDataResponse, sizeof(fact__findServiceDataResponse *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (fact__findServiceDataResponse *)soap_instantiate_fact__findServiceDataResponse(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (fact__findServiceDataResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTofact__findServiceDataResponse, sizeof(fact__findServiceDataResponse *), 1), SOAP_TYPE_fact__findServiceDataResponse, sizeof(fact__findServiceDataResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofact__destroyResponse(struct soap *soap, fact__destroyResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTofact__destroyResponse))
		soap_mark_PointerTofact__destroyResponse(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTofact__destroyResponse(struct soap *soap, fact__destroyResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_fact__destroyResponse))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTofact__destroyResponse(struct soap *soap, fact__destroyResponse **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofact__destroyResponse(struct soap *soap, fact__destroyResponse **a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTofact__destroyResponse);
	soap_out_PointerTofact__destroyResponse(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofact__destroyResponse(struct soap *soap, const char *tag, int id, fact__destroyResponse *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTofact__destroyResponse);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_fact__destroyResponse, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_fact__destroyResponse, &pp), type);
}

SOAP_FMAC3 fact__destroyResponse ** SOAP_FMAC4 soap_get_PointerTofact__destroyResponse(struct soap *soap, fact__destroyResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofact__destroyResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 fact__destroyResponse ** SOAP_FMAC4 soap_in_PointerTofact__destroyResponse(struct soap *soap, const char *tag, fact__destroyResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (fact__destroyResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTofact__destroyResponse, sizeof(fact__destroyResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (fact__destroyResponse **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTofact__destroyResponse, sizeof(fact__destroyResponse *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (fact__destroyResponse *)soap_instantiate_fact__destroyResponse(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (fact__destroyResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTofact__destroyResponse, sizeof(fact__destroyResponse *), 1), SOAP_TYPE_fact__destroyResponse, sizeof(fact__destroyResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofact__findByHandleResponse(struct soap *soap, fact__findByHandleResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTofact__findByHandleResponse))
		soap_mark_PointerTofact__findByHandleResponse(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTofact__findByHandleResponse(struct soap *soap, fact__findByHandleResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_fact__findByHandleResponse))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTofact__findByHandleResponse(struct soap *soap, fact__findByHandleResponse **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofact__findByHandleResponse(struct soap *soap, fact__findByHandleResponse **a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTofact__findByHandleResponse);
	soap_out_PointerTofact__findByHandleResponse(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofact__findByHandleResponse(struct soap *soap, const char *tag, int id, fact__findByHandleResponse *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTofact__findByHandleResponse);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_fact__findByHandleResponse, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_fact__findByHandleResponse, &pp), type);
}

SOAP_FMAC3 fact__findByHandleResponse ** SOAP_FMAC4 soap_get_PointerTofact__findByHandleResponse(struct soap *soap, fact__findByHandleResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofact__findByHandleResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 fact__findByHandleResponse ** SOAP_FMAC4 soap_in_PointerTofact__findByHandleResponse(struct soap *soap, const char *tag, fact__findByHandleResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (fact__findByHandleResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTofact__findByHandleResponse, sizeof(fact__findByHandleResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (fact__findByHandleResponse **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTofact__findByHandleResponse, sizeof(fact__findByHandleResponse *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (fact__findByHandleResponse *)soap_instantiate_fact__findByHandleResponse(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (fact__findByHandleResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTofact__findByHandleResponse, sizeof(fact__findByHandleResponse *), 1), SOAP_TYPE_fact__findByHandleResponse, sizeof(fact__findByHandleResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofact__createNewTreeResponse(struct soap *soap, fact__createNewTreeResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTofact__createNewTreeResponse))
		soap_mark_PointerTofact__createNewTreeResponse(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_PointerTofact__createNewTreeResponse(struct soap *soap, fact__createNewTreeResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_fact__createNewTreeResponse))
		(*a)->soap_mark(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_PointerTofact__createNewTreeResponse(struct soap *soap, fact__createNewTreeResponse **a)
{
	*a = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofact__createNewTreeResponse(struct soap *soap, fact__createNewTreeResponse **a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_PointerTofact__createNewTreeResponse);
	soap_out_PointerTofact__createNewTreeResponse(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofact__createNewTreeResponse(struct soap *soap, const char *tag, int id, fact__createNewTreeResponse *const*a, const char *type)
{
	struct soap_plist *pp;
	register int i;
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTofact__createNewTreeResponse);
	if (!*a)
		return soap_element_null(soap, tag, id, type);
	i = soap_pointer_lookup(soap, *a, SOAP_TYPE_fact__createNewTreeResponse, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
			return soap_element_ref(soap, tag, id, i);
		if (soap_is_single(soap, pp))
			return (*a)->soap_out(soap, tag, 0, type);
		soap_set_embedded(soap, pp);
		return (*a)->soap_out(soap, tag, i, type);
	}
	return (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_fact__createNewTreeResponse, &pp), type);
}

SOAP_FMAC3 fact__createNewTreeResponse ** SOAP_FMAC4 soap_get_PointerTofact__createNewTreeResponse(struct soap *soap, fact__createNewTreeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofact__createNewTreeResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 fact__createNewTreeResponse ** SOAP_FMAC4 soap_in_PointerTofact__createNewTreeResponse(struct soap *soap, const char *tag, fact__createNewTreeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (fact__createNewTreeResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTofact__createNewTreeResponse, sizeof(fact__createNewTreeResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (fact__createNewTreeResponse **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTofact__createNewTreeResponse, sizeof(fact__createNewTreeResponse *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (fact__createNewTreeResponse *)soap_instantiate_fact__createNewTreeResponse(soap, -1, soap->type, soap->arrayType, NULL);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (fact__createNewTreeResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTofact__createNewTreeResponse, sizeof(fact__createNewTreeResponse *), 1), SOAP_TYPE_fact__createNewTreeResponse, sizeof(fact__createNewTreeResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__string(struct soap *soap, char **a)
{
#ifdef SOAP_DEFAULT_xsd__string
	*a = SOAP_DEFAULT_xsd__string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__string);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_xsd__string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__string(struct soap *soap, char **a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_xsd__string);
	soap_out_xsd__string(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__string);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__string(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__string(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__string, 1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_mark_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char **a, const char *tag, const char *type)
{
	int i = soap_embed_element(soap, (void*)a, tag, SOAP_TYPE_string);
	soap_out_string(soap, tag, i, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1);
}

SOAP_END_NAMESPACE(checkPointTree)

/* end of checkPointTreeC.cpp */
